#ifndef _ASSCANL_H_#define _ASSCANL_H_/* *	This file contains definitions local to the files implementing *	the character scanner and the token buffer managers. *	It is not intended to be shared with any other parts of the *	assembler. *	The file ``asscan.h'' is shared with other parts of the assembler */#include "mstdio.h"#include "as.h"#include "asscan.h"#define EOFCHAR	(-1)/* *	The table of possible uses for each character to test set inclusion. */#define	HEXFLAG		01		/* 'x' or 'X' */#define	HEXLDIGIT	02		/* 'a' .. 'f' */#define	HEXUDIGIT	04		/* 'A' .. 'F' */#define	ALPHA		010		/* 'A' .. 'Z', 'a' .. 'z', '_'*/#define	DIGIT		020		/* '0' .. '9' */#define	FLOATEXP	040		/* 'd' 'e' 'D' 'E' 'g' 'h' 'G' 'H' */#define	SIGN		0100		/* '+' .. '-'*/#define	REGDIGIT	0200		/* '0' .. '5' */#define	SZSPECBEGIN	0400		/* 'b', 'B', 'l', 'L', 'w', 'W' */#define	POINT		01000		/* '.' */#define	SPACE		02000		/* '\t' or ' ' */#define	BSESCAPE	04000		/* bnrtf */#define	STRESCAPE	010000		/* '"', '\\', '\n' */#define	OCTDIGIT	020000		/* '0' .. '7' */#define	FLOATFLAG	040000		/* 'd', 'D', 'f', 'F' */#define	INCHARSET(val, kind) (charsets[val+1] & (kind) )/* *	We use our own version of getchar/ungetc to get *	some speed improvement */extern	char	*Ginbufptr;extern	long	Ginbufcnt;#define	REGTOMEMBUF	Ginbufptr = inbufptr, Ginbufcnt = inbufcnt#define	MEMTOREGBUF	inbufptr = Ginbufptr, inbufcnt = Ginbufcnt#undef getchar#define	getchar() \	(inbufcnt-- > 0 ? (*inbufptr++) : \		(fillinbuffer(), \		MEMTOREGBUF, \		inbufptr[-1]))#undef ungetc#define ungetc(ch) \	(++inbufcnt, *(--inbufptr) = ch)/* *	Variables and definitions to manage the token buffering. *	We scan (lexically analyze) a large number of tokens, and *	then parse all of the tokens in the scan buffer. *	This reduces procedure call overhead when the parser *	demands a token, allows for an efficient reread during *	the second pass, and confuses the line number reporting *	for errors encountered in the scanner and in the parser. */#define TOKDALLOP	8extern struct	tokbufdesc *bufstart;	/*where the buffer list begins*/extern struct	tokbufdesc *buftail;	/*last one on the list*/extern struct	tokbufdesc *emptybuf;	/*the one being filled*//* *	If we are using VM, during the second pass we reclaim the used *	token buffers for saving the relocation information */extern struct	tokbufdesc *tok_free;	/* free pool */extern struct	tokbufdesc *tok_temp;	/* temporary for doing list manipulation *//* *	Other token buffer managers */extern long	bufno;			/*which buffer number: 0,1 for tmp file*/extern struct 	tokbufdesc *tokbuf;	/*our initial increment of buffers*/extern ptrall	tokptr;			/*where the current token comes from*/extern ptrall	tokub;			/*the last token in the current token buffer*//* *	as does not use fread and fwrite for the token buffering. *	The token buffers are integrals of BUFSIZ *	at all times, so we use direct read and write. *	fread and fwrite in stdio are HORRENDOUSLY inefficient, *	as they use putchar for each character, nested two deep in loops. */#define writeTEST(pointer, size, nelements, ioptr) \	mwrite(ioptr->_file, pointer, nelements * size) != nelements * size#define readTEST(pointer, size, nelements, ioptr) \	mread(ioptr->_file, pointer, nelements * size) != nelements * size#define bskiplg(from, length) \	*(lgtype *)from = length; \	(bytetoktype *)from += sizeof(lgtype) + length#define bskipfromto(from, to) \	*(lgtype *)from = (bytetoktype *)to - (bytetoktype *)from - sizeof(lgtype); \	(bytetoktype *)from += sizeof (lgtype) + (bytetoktype *)to - (bytetoktype *)from#define eatskiplg(from) \	(bytetoktype *)from += sizeof(lgtype) + *(lgtype *)from#ifdef DEBUG	extern ptrall	firsttoken;#endif DEBUG/* *	The following three variables are the slots for global *	communication with the parser. *	They are the semantic values associated with a particular token. *	The token itself is the return value from yylex() */extern long	yylval;			/* normal semantic value */extern Bignum	yybignum;		/* a big number */extern struct	Opcode	yyopcode;	/* a structure opcode */extern long	newfflag;extern char	*newfname;extern long	scanlineno;		/*the scanner's linenumber*//* *	Definitions for sets of characters */extern readonly short charsets[];extern readonly short type[];#endif