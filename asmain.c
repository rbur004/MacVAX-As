#include	<types.h>#include	<quickdraw.h>#include	<toolutils.h>#include	<fonts.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include 	<ctype.h>#include 	<signal.h>//#include 	<ioctl.h>#include 	<Memory.h>#include	<StdIO.h>#include	<StdLib.h>#include	<String.h>#ifdef DEBUG#define DEBUG_1#endif#include "mstdio.h"#include "as.h"#include "assyms.h"#include "asscan.h"#include "asexpr.h"#include "asmain.h"#include "aprintf.h"#include "asio.h"#include "asparse.h"#include "asjxxx.h"#include "unix.h"#include "macio.h"#include "iow.h"#include 	"stat.h"#include		"asinclude.h"#include 	"mmalloc.h"#include 	"a.out.h"#define	unix_lang_name "VAX/UNIX Assembler V10/21/85 5.2"/* *	variables to manage reading the assembly source files */ extern	char		MainFileName[SizeFileNameVI];   /* to display it, belong to asinclude.c */char	*dotsname;	/*the current file name; managed by the parser*/MFILE **innames;	/*names and fds of the files being assembled*/long curr_in_fd;long	ninfiles;	/*how many interesting files there are*/long	lineno;		/*current line number; managed by the parser*//* *	Flags settable from the argv process argument list */long	silent = 0;	/*don't complain about any errors*/long	savelabels = 1;	/* do write all the labels to the a.out file*/long 	d124 = 4;	/*default allocate (1 was 4) bytes for unknown pointers*/long 	maxalign = 2;	/*default .align maximum*/long	anyerrs = 0;	/*no errors yet*/long	anywarnings=0;	/*no warnings yet*/long	orgwarn = 0;	/*Bad origins*/long	passno = 1;	/* current pass*/long	jxxxJUMP = 0;	/* in jxxxes that branch too far, use jmp instead of brw */long	readonlydata = 0;	/* initialzed data -> text space */long	nGHnumbers = 0;		/* GH numbers used */long	nGHopcodes = 0;		/* GH opcodes used */long	nnewopcodes = 0;	/* new opcodes used */#ifdef DEBUGlong 	debug = 0;long	toktrace = 0;#endiflong	useVM =	0;char	*endcore;	/*where to get more symbol space*/int is_boot_file;	/* RTB 22/6/93 boolean. Whether a .boot directive has been encountered *//* *	Managers of the a.out file. */struct	exec_struct hdr;#define	MAGIC	0410u_long	tsize;		/* total text size */u_long	dsize;		/* total data size */u_long	datbase;		/* base of the data segment */u_long	code_base_address;		/* base of the code segment */u_long	trsize;		/* total text relocation size */u_long	drsize;		/* total data relocation size *//* *	Information about the current segment is accumulated in *	usedot; the most important information stored is the *	accumulated size of each of the text and data segments * *	dotp points to the correct usedot expression for the current segment */struct	exp	usedot[NLOC+NLOC];	/* info about all segments */struct	exp	*dotp;			/* data/text location pointer *//* *	The inter pass temporary token file is opened and closed by stdio, but *	is written to using direct read/write, as the temporary file *	is composed of buffers exactly BUFSIZ long. */M_FILE	*tokfile;			/* interpass communication file */char	tokfilename[TNAMESIZE];/* *	The string file is the string table *	cat'ed to the end of the built up a.out file */M_FILE	*strfile;			/* interpass string file */char	strfilename[TNAMESIZE];long	strfilepos = 0;			/* position within the string file *//* *	a.out is created during the second pass. *	It is opened by stdio, but is filled with the parallel *	block I/O library */char	*outfile;MFILE	*a_out_file;MFILE   last_a_out_file;off_t	a_out_off;			/* cumulative offsets for segments *//* *	The logical files containing the assembled data for each of *	the text and data segments are *	managed by the parallel block I/O library. *	a.out is logically opened in many places at once to *	receive the assembled data from the various segments as *	it all trickles in, but is physically opened only once *	to minimize file overhead. */BFILE	*usefile[NLOC+NLOC];		/* text/data files */BFILE	*txtfil;			/* current text/data file *//* *	Relocation information is accumulated seperately for each *	segment.  This is required by the old loader (from BTL), *	but not by the new loader (Bill Joy).   * *	However, the size of the relocation information can not be computed *	during or after the 1st pass because the ''absoluteness' of values *	is unknown until all locally declared symbols have been seen. *	Thus, the size of the relocation information is only *	known after the second pass is finished. *	This obviates the use of the block I/O *	library, which requires knowing the exact offsets in a.out. * *	So, we save the relocation information internally (we don't *	go to internal files to minimize overhead). * *	Empirically, we studied 259 files composing the system, *	two compilers and a compiler generator: (all of which have *	fairly large source files) *	 *	Number of files = 259 *		Number of non zero text reloc files: 233 *		Number of non zero data reloc files: 53 *	Average text relocation = 889 *	Average data relocation = 346 *	Number of files > BUFSIZ text relocation = 71 *	Number of files > BUFSIZ data relocation = 6 *	 *	For compiled C code, there is usually one text segment and two *	data segments; we see that allocating our own buffers and *	doing our internal handling of relocation information will, *	on the average, not use more memory than taken up by the buffers *	allocated for doing file I/O in parallel to a number of file. *	 *	If we are assembling with the -V option, we *	use the left over token buffers from the 2nd pass, *	otherwise, we create our own. * *	When the 2nd pass is complete, closeoutrel flushes the token *	buffers out to a BFILE. * *	The internals to relbufdesc are known only in assyms.c * *	outrel constructs the relocation information. *	closeoutrel flushes the relocation information to relfil. */extern struct	relbufdesc	*rusefile[NLOC+NLOC];	extern struct	relbufdesc 	*relfil;	/* un concatnated relocation info */BFILE	*relocfile;			/* concatnated relocation info *//* *	Once the relocation information has been written, *	we can write out the symbol table using the Block I/O *	mechanisms, as we once again know the offsets into *	the a.out file. * *	We use relfil to output the symbol table information. */char	*tmpdirprefix = "\0";extern struct tokbufdesc *tokbuf;#ifdef DEBUG	extern ptrall	firsttoken;#endif/* a bit map for recording where instructions start */char *bit_map;jmp_buf env;extern long mem_allocated;void add_extra_symbols();	/* RTB 15/7/93 add .version and .origin into the symbol table */#pragma segment ASMAINlong vax_assemble(	long	argc,	MFILE 	**argv,	char	*NameOrigFile){extern short type[];long error_state;char OutFile[256];		sprintf(OutFile, "%s.out", (*argv)->name);	outfile = OutFile;#ifdef DEBUG_1	iowprintf("Assemble: %s\n", (*argv)->name );#endif		assem_setup();	if( error_state = setjmp( env )) //YEs that is one =	{		return( error_state );	}		tokfilename[0] = 0;	strfilename[0] = 0;		argprocess(argc, argv);		/* process argument lists */#ifdef DEBUG_1	iowprintf("Processed args\n");#endif	if (anyerrs) myexit(1);				initialize();	zeroorigins();			/* set origins to zero */	zerolocals();			/* fix local label counters */#ifdef DEBUG_1	iowprintf("Initialize,zeroorigins and zerolocals completed\n");#endif	/* open a.out. SHIFTED so we know outfile dirs vrefnum sooner*/	open_a_out(NameOrigFile);	 /* @@ */#ifdef DEBUG_1	iowprintf("open_a_out completed\n");#endif	i_pass1();			/* open temp files, etc */	pass1();			/* first pass through .s files */	testlocals();			/* check for undefined locals */			if (anyerrs) delexit();	#ifdef DEBUG_1	iowprintf("pass1 completed\n");#endif	pass1_5();			/* resolve jxxx */	if (anyerrs) delexit();	roundsegments();		/* round segments to FW */	build_hdr();			/* build initial header, and output */	#ifdef DEBUG_1	iowprintf("pass1.5 completed\n");#endif		i_pass2();			/* reopen temporary file, etc */	pass2();			/* second pass through the virtual .s */	if (anyerrs) delexit();	fillsegments();			/* fill segments with 0 to FW */	reloc_syms();			/* dump relocation and symbol table */#ifdef DEBUG_1	iowprintf("pass2 completed\n");#endif	delete();			/* remove tmp file */	bflush();			/* close off block I/O view of a.out */	fix_a_out();			/* add in text and data reloc counts */	/* RTB 22/6/93 if we have encountered a .boot directive change the type of the */	/* file to be a BOOT file */	if (is_boot_file)		settype(outfile,a_out_file->vrefnum,"BOOT","VSIM");		if (anyerrs == 0 && orgwarn)		yyerror("Caution: absolute origins.\n");	if (nGHnumbers)		yywarning("Warning: G or H format floating point constants used.");	if (nGHopcodes)		yywarning("Warning: G or H format floating point instructions used.");	if (nnewopcodes)		yywarning("Warning: 2 byte Opcodes Used. ");	if (nGHnumbers || nGHopcodes || nnewopcodes)		yywarning("G or H numbers and opcodes and the 2 byte opcodes are not implemented on all VAX's.\n");	if(anyerrs == 0)	{			iowprintf( "Assembly complete. No errors\n");	}	else	{			munlink(last_a_out_file.name,last_a_out_file.vrefnum);			iowprintf( "Assembly aborted due to errors\n");	}		return(anyerrs != 0);}/*  *	called ONCE upon startup */void assem_init(void){	load_instruction_table();	init_sbrk();  /* set up mem, for Callocs and ClearCallocs */		/* create space for static vars */	if( (tokbuf = ( struct tokbufdesc * )mcalloc( 2, sizeof( struct tokbufdesc ))) == 0)	{		aprintf("Unable to get enough memory to allocate tokbuf");		exit(1);	}#ifdef DEBUG_1	aprintf("tokbuf allocated at %x for %d\n",tokbuf,sizeof( struct tokbufdesc )*2);#endif}	/*  *	run each time in assem. *	  *	BIG CAUTION: is hacky in that these defines are elsewhere as well. */#define	JBRDELTA	1	/* brb <byte> ==> brw <byte> <byte> */#define	JXXXDELTA	3	/* brb <byte> ==> brb <byte> brw <byte> <byte> */extern long jbrfsize;extern long jxxxfsize;extern long exprisname;extern long droppedLP;extern char	UDotsname[64];	/*name of the assembly source*/#define	ASINBUFSIZ	4096extern char	inbufunget[8];extern char	inbuffer[ASINBUFSIZ];#define	NUMSIZE	128	/* how many characters long a number can be */extern 	char	numbuf[NUMSIZE];extern struct	symtab		**symdelim[NLOC + NLOC +1];extern Iptr	*itab[NINST];	/*maps opcodes to instructions*/extern inttoktype oval;extern char *Ginbufptr;extern long Ginbufcnt;extern long scannerhadeof;extern struct	hashdallop	*htab;extern Bignum	Znumber;			/* zero reference */extern struct	tokbufdesc	*bufstart,					*buftail,					*emptybuf,					*tok_free,					*tok_temp;extern long bufno;extern long		yylval;extern Bignum	yybignum;extern struct	Opcode		yyopcode;extern long		newfflag;extern char	*newfname;extern long		scanlineno;extern	long pass1_count; extern	long pass2_count; void assem_setup(void){	dotsname = NULL;	/*the current file name; managed by the parser*/	lineno = 0;		/*current line number; managed by the parser*/	innames = NULL;	/*names and fds of the files being assembled*/	curr_in_fd = 0;	ninfiles = 0;	/*how many interesting files there are*/	silent = 0;	/*don't complain about any errors*/	savelabels = 1;	/*write the labels to the a.out file*/ 	d124 = 4 ;	/*default allocate 4 bytes for unknown pointers*/ 	maxalign = 2;	/*default .align maximum*/	anyerrs = 0;	/*no errors yet*/	anywarnings=0;	/*no warnings yet*/	orgwarn = 0;	/*Bad origins*/	passno = 1;	/* current pass*/	jxxxJUMP = 0;	/* in jxxxes that branch too far, use jmp instead of brw */	readonlydata = 0;	/* initialzed data -> text space */	nGHnumbers = 0;		/* GH numbers used */	nGHopcodes = 0;		/* GH opcodes used */	nnewopcodes = 0;	/* new opcodes used */	include_stack_depth = 0;	/* haven't .inlcuded any files yet */#ifdef DEBUG 	debug = 0;	toktrace = 0;#endif	useVM =	0;	tmpdirprefix = "\0";	relfil = NULL;	relocfile = txtfil = NULL;	a_out_file = NULL;				a_out_off = 0;			/* cumulative offsets for segments */	strplhead = 0;		mem_allocated = 0;	/* amount currently allocated */	endcore = (char *) sbrk( 0 );		memset( &hdr, 0, sizeof( hdr ));	tsize = 0;		/* total text size */	dsize = 0;		/* total data size */	datbase = 0;	/* base of the data segment */	code_base_address = 0;	/* base of the code segment */	trsize = 0;		/* total text relocation size */	drsize = 0;		/* total data relocation size */	memset( usedot, 0, sizeof( usedot ));	dotp = NULL; 		tokfile = NULL;			/* interpass communication file */	memset( tokfilename, 0, sizeof( tokfilename ));	strfile = NULL;			/* interpass string file */	memset( strfilename, 0, sizeof( strfilename ));	strfilepos = 0;			/* position within the string file */	memset( usefile, 0, sizeof( usefile ));//	memset( rusefile, 0, sizeof( rusefile ));	memset( rusefile, 0, ((NLOC+NLOC) * sizeof(struct relbufdesc *) ) );			biofd = 0;			/* file descriptor for block I/O file */	biobufsize = 0;		/* optimal block size for I/O */	boffset = 0;		/* physical position in logical file */	biobufs = NULL;		/* the block I/O buffers */	jbrfsize = JBRDELTA;	jxxxfsize = JXXXDELTA;	lastnam = NULL;	lastjxxx = NULL;	memset( lgensym, 0, sizeof(lgensym) );	memset( genref, 0, sizeof(genref) );	bitfield = 0L;	bitoff = 0;	curlen = 0;			/* current length of literals *//* *	The following three variables are communication between various *	modules to special case a number of things.  They are properly *	categorized as hacks. */	exprisname = 0;		/*last factor in an expression was a name*/	droppedLP = 0;		/*one is analyzing an expression beginning with*/				/*a left parenthesis, which has already been*/				/*shifted. (Used to parse (<expr>)(rn)*/	memset( yytext, 0, sizeof( yytext));		xp = NULL;			memset( explist, 0, sizeof( explist ));		memset( arglist, 0, sizeof( arglist ));		memset( tokensets, 0, sizeof( tokensets ));		memset( UDotsname, 0, sizeof( UDotsname ));		oval = NL;	memset( inbufunget, 0, sizeof( inbufunget ));	memset( inbuffer, 0, sizeof( inbuffer ));	Ginbufptr = inbuffer;	Ginbufcnt = 0;	scannerhadeof = 0;	memset( numbuf, 0, sizeof( numbuf ));	allochead = NULL;	/*head of chunk list*/	alloctail = NULL;	/*tail*/	newbox = NULL;	/*for creating a new chunk*/	nextsym = NULL;	/*next symbol free*/	symsleft = 0;	/*slots left in current chunk*/	symptrs = NULL;	memset( symdelim, 0, sizeof( symdelim ));	symptrub = NULL;	htab = NULL;		memset( itab, 0, sizeof( itab ));	nsyms = 0;		/* total number in the symbol table */	njxxx = 0;		/* number of jxxx entrys */	nforgotten = 0;	/* number of symbols erroneously entered */ 	nlabels = 0;	/* number of label entries */	strplhead = NULL;	memset( &Znumber, 0, sizeof(Znumber)) ;			/* zero reference */	relfil = NULL;	tokptr = NULL;	tokub = NULL;	bufstart = buftail = emptybuf = tok_free = tok_temp = NULL;	bufno = 0;#ifdef DEBUG	firsttoken = NULL;#endif	yylval = 0;	memset( &yybignum, 0, sizeof( yybignum ));	memset( &yyopcode, 0, sizeof( yyopcode ));	newfflag = 0;	newfname = 0;	scanlineno = 0;		is_boot_file = 0;	/* RTB 22/6/93 boolean. Whether a .boot directive has been encountered */	/* Initialise 2 variable of asparse.c on this level */	/* because need to be done, before each compilation */	pass1_count = 0;	pass2_count = 0;}void argprocess(	long	argc,	MFILE **argv){#ifdef DONTWANT	register	char	*cp;#endif	ninfiles = argc;	silent = 0;#ifdef DEBUG		debug=1;toktrace=1;#endif	innames = argv;	return;	#ifdef DONTWANT	while (argc > 1) {		if (argv[1][0] != '-')			innames[ninfiles++] = argv[1];		else {			cp = argv[1] + 1;			/*			 *	We can throw away single minus signs, so			 *	that make scripts for the PDP 11 assembler work			 *	on this assembler too			 */			while (*cp){					switch(*cp++){				 default:					yyerror("Unknown flag: %c", *--cp);					cp++;					break;				 case 'd':					d124 = *cp++ - '0';					if ( (d124 != 1) && (d124 != 2) && 					     (d124 != 4)){						yyerror("-d[124] only");						myexit(1);					}					break;				 case 'a':					maxalign = atoi(cp+1);					for (cp++; isdigit(*cp); cp++)						/*VOID*/;					if ( (maxalign > 16) || (maxalign < 0)){						yyerror("-a: 0<=align<=16");						myexit(1);					}					break;				 case 'o':					if (argc < 3){						yyerror("-o what???");						myexit(1);					}					outfile = argv[2];				   bumpone:					argc -= 2;					argv += 2;					goto nextarg;				 case 't':					if (argc < 3){						yyerror("-t what???");						myexit(1);					}					tmpdirprefix = argv[2];					goto bumpone;				 				 case 'V':					useVM = 1;					break;				 case 'W':					silent = 1;					break;				 case 'L':					savelabels = 1;					break;				 case 'J':					jxxxJUMP = 1;					break;#ifdef DEBUG				 case 'D':					debug = 1;					break;				 case 'T':					toktrace = 1;					break;#endif				 case 'R':					readonlydata = 1;					break;				}	/*end of the switch*/			}	/*end of pulling out all arguments*/		}	/*end of a flag argument*/		--argc; ++argv;	   nextarg:;	}	/* innames[ninfiles] = 0; */#endif}/* *	A wee hack to overcome the limitations *	on global arrays the Mac has.  The table of *	instructions is read in from a resource. *	The resource has name "InSt" and id's 128 (data) *	and 129 (strings) */ struct Instab *instab;		/* the new actual declaration for instab */static	Handle data = 0;static	Handle strings = 0;void load_instruction_table(void){	register struct Instab *tabptr;	register unsigned long offset;		data = GetResource( (ResType)'InSt',(short) 128 );	if(data == (Handle)0)	{		aprintf("Fail Instruction table load:  Reserror = %d\n",ResError());		myexit(0);	}	strings = GetResource( (ResType)'InSt',(short) 129 );	if(strings == (Handle)0)	{			aprintf("Failed strings table load: Reserror = %d\n",ResError()); 		myexit(0);	} 	MaxApplZone();  	MoveHHi(data);	MoveHHi(strings);	HLock(data);		HLock(strings);		instab = (struct Instab *) (*data) ;	/* correct the strings pointers */	for( tabptr = instab, offset = (unsigned long)(*strings)-1; tabptr->I_name; tabptr++ )		tabptr->I_name += offset;}		void initialize(void){/*	if (sigset(SIGINT, SIG_IGN) != SIG_IGN)		sigset(SIGINT, delexit);	/*	 *	Install symbols in the table	 */	symtabinit();	syminstall();	/*	 *	Build the expression parser accelerator token sets	 */	buildtokensets();		}void zeroorigins(void){	register	long	locindex;	/*	 *	Mark usedot: the first NLOC slots are for named text segments,	 *	the next for named data segments.	 */	for (locindex = 0; locindex < NLOC; locindex++)	{		usedot[locindex].e_xtype = XTEXT;		usedot[NLOC + locindex].e_xtype = XDATA;		usedot[locindex].e_xvalue = 0;		usedot[NLOC + locindex].e_xvalue = 0;	}}void zerolocals(void){	register	long	i;	for (i = 0; i <= 9; i++)	{		lgensym[i] = 1;		genref[i] = 0;	}}void i_pass1(void){	if (useVM == 0)		tokfile = tempopen(tokfilename, "T");	strfile = tempopen(strfilename, "S");	/*	 *	write out the string length.	 *	This will be overwritten when the	 *	strings are tacked onto the growing a.out file	 */	strfilepos = sizeof(long);	mfwrite((char *)&strfilepos,(long) sizeof(long), (long)1, strfile);		inittokfile();	initijxxx();	}M_FILE *tempopen(	char	*tname,	char	*part){	M_FILE	*file;	sprintf(tname, "astmp%s", part);	file = mfopen(tname,a_out_file->vrefnum, "w+");	if (file == NULL) {		yyerror("Bad pass 1 temporary file for writing %s", tname);		delexit();	}	/* RTB 11/3/93 change type from text so that AUFS doesn't change line feeds */	/* to carriage returns and vice versa */	settype(tname,a_out_file->vrefnum,"TEMP","????");	return(file);}void pass1(void){	register	long	i;	passno = 1;	dotp = &usedot[0];	txtfil = (BFILE *)0;	relfil = (struct relbufdesc *)0;		/* files now passed by file descriptors */		/* Old staff, actually we never use more than one file so : */	/*	for( i=0; i<ninfiles; i++ )	{			new_dot_s( (innames[i])->name );			iowprintf("Assembling: %s\n", (innames[i])->name);		curr_in_fd = (innames[i])->fd;		yyparse();	}	*/		/* Do the job of the part in comment above, but only for one file */	/* and give the real name of the file (not the name of the buffer */	i=0;	new_dot_s( (innames[i])->name );	iowprintf("Assembling: %s\n", MainFileName);	curr_in_fd = (innames[i])->fd;	/* remember the original file name so that if we include other files */	/* we know where to return to (RTB) */	include_file[include_stack_depth].f = innames[i];	include_file[include_stack_depth].lineno = 1;	/* irrelevant at this point */	yyparse();	i++;			closetokfile();	return;		}void testlocals(void){	register	long	i;	for (i = 0; i <= 9; i++) {		if (genref[i])			yyerror("Reference to undefined local label %df", i);		lgensym[i] = 1;		genref[i] = 0;	}}typedef unsigned char byte;void add_extra_symbols()	/* RTB 15/7/93 add .version and .origin into the symbol table */{	struct symtab *sym_ent;	Handle		versionH;	byte *vers;	long vnum;	sprintf(yytext,".orig");	sym_ent = *lookup(1);				/* bung it in */	sym_ent -> s_type = N_ABS;	sym_ent -> s_value = code_base_address;	sym_ent -> s_index = 0;/*	iowprintf(".origin = %d\n",sym_ent -> s_value); */	/* work out the version number of As */	if((versionH = GetResource('vers',(short)128)) != (Handle)0)	{		HLock(versionH);		vers = (byte *) *versionH;		/* good grief. The version number is in BCD */		vnum = 100 * (vers[0] & 0xF);		vnum+= 10 * ((vers[1] & 0xF0) >> 4);		vnum+= (vers[1] & 0xF);	}		sprintf(yytext,".version");	/* put the version number into the symbol table */	sym_ent = *lookup(1);				/* bung it in */	sym_ent -> s_type = N_ABS;	sym_ent -> s_value = vnum;	sym_ent -> s_index = 0;/*	iowprintf(".version = %d\n",sym_ent -> s_value); */	}void pass1_5(void){	add_extra_symbols();	/* RTB 15/7/93 add .version and .origin into the symbol table */	sortsymtab();#ifdef DEBUG	if (debug) dumpsymtab();#endif 	/* dumpsymtab(); */	jxxxfix();/* dumpsymtab(); */#ifdef DEBUG	if (debug) dumpsymtab();#endif}extern  IdOrigFile;void open_a_out(	char  *NameOrigFile){/*	struct stat stb;*/	/*	 *	Open up the a.out file now, and get set to build	 *	up offsets into it for all of the various text,data	 *	text relocation and data relocation segments.	 *//*	strcpy (outfile,NameOrigFile); *//*	strcat (outfile,".out");		*/	a_out_file = mcreat("Assembled Filename",outfile, 'VSIM', 'AOUT');	if (a_out_file == NULL)	{/*		strcpy (outfile,NameOrigFile);	*//*		strcat (outfile,".out");			*/		iowprintf("Cannot create %s", outfile);  /* @@ */		myexit(1);	}	outfile = a_out_file->name;	last_a_out_file = *a_out_file; /*save so we know name and vrefnum for transfer command*/	biofd = a_out_file->fd;		/* 	 *	done with an ioctl call on the mac 	 *	 *	fstat(biofd, &stb);	 *	biobufsize = stb.st_blksize;	 *	 */			/* not sure, so take a guess... */	biobufsize = 1024;	a_out_off = 0;}void roundsegments(void){	register	long	locindex;	register	long	v;	/*	 *	round and assign text segment origins	 *	the exec header always goes in usefile[0]	 */	tsize = 0;	for (locindex=0; locindex<NLOC; locindex++) {		v = round(usedot[locindex].e_xvalue, FW);		usedot[locindex].e_xvalue = code_base_address + tsize;		if ((locindex == 0) || (v != 0) ){			usefile[locindex] = (BFILE *)ClearCalloc(1, sizeof(BFILE));#ifdef DEBUG	iowprintf("usefile[locindex] in roundsegments() allocated at %x for %d\n",usefile[locindex],sizeof(BFILE));#endif			bopen(usefile[locindex], a_out_off);			if (locindex == 0)				a_out_off = sizeof (struct exec_struct);		} else {			usefile[locindex] = (BFILE *)-1;		}		tsize += v;		a_out_off += v;	}	/*	 *		Round and assign data segment origins.	 */	datbase = round(code_base_address + tsize, BLOCKBOUND);	for (locindex=0; locindex<NLOC; locindex++) {		v = round(usedot[NLOC+locindex].e_xvalue, FW);		usedot[NLOC+locindex].e_xvalue = datbase + dsize;		if (v != 0){			usefile[NLOC + locindex] = (BFILE *)ClearCalloc(1,sizeof(BFILE));#ifdef DEBUG	iowprintf("usefile[NLOC + locindex] in roundsegments() allocated at %x for %d\n",usefile[NLOC + locindex],sizeof(BFILE));#endif			bopen(usefile[NLOC + locindex], a_out_off);		} else {			usefile[NLOC + locindex] = (BFILE *)-1;		}		dsize += v;		a_out_off += v;	}	/*	 *	Assign final values to symbols	 */	hdr.a_bss = dsize;	freezesymtab();		/* this touches hdr.a_bss */	stabfix();	/*	 *	Set up the relocation information "files" to	 *	be zero; outrel takes care of the rest	 */	for (locindex = 0; locindex < NLOC + NLOC; locindex++){		rusefile[locindex] = (struct relbufdesc *)0;	}}void build_hdr(void){	struct exec_struct temp;	/* must reverse the order of bytes */						/* for the MAC */							/*	 *	Except for the text and data relocation sizes,	 *	calculate the final values for the header	 *		 *	Write out the initial copy; we to come 	 *	back later and patch up a_trsize and a_drsize,	 *	and overwrite this first version of the header.	 */	hdr.a_magic = MAGIC;	hdr.a_text = tsize ;	hdr.a_data = dsize;	hdr.a_bss -= dsize;	hdr.a_syms = sizesymtab();	/* Does not include string pool length */	hdr.a_entry = 0;	hdr.a_trsize = 0;	hdr.a_drsize = 0;		temp.a_magic = REVLONG( hdr.a_magic );	temp.a_text = REVLONG( hdr.a_text );	temp.a_data = REVLONG( hdr.a_data );	temp.a_bss = REVLONG( hdr.a_bss );	temp.a_syms = REVLONG( hdr.a_syms );	temp.a_entry = REVLONG( hdr.a_entry );	temp.a_trsize = REVLONG( hdr.a_trsize );	temp.a_drsize = REVLONG( hdr.a_drsize );	bwrite((char *)&temp, sizeof(temp), usefile[0]);}void i_pass2(void){	/* allocate space for the instruction bit map (ensure it is zeroed) */	bit_map = ClearCalloc( ( tsize+7 )>>3, 1 );#ifdef DEBUG	iowprintf("A bit_map allocated at %x for %d\ntsize was %d\n",bit_map,( tsize+7 )>>3, tsize);#endif	if (useVM == 0) {/*		mfclose(tokfile);*		tokfile = mfopen(tokfilename,a_out_file->vrefnum, "r");*		if (tokfile==NULL) {*		   yyerror("Bad pass 2 temporary file for reading %s", tokfilename);*		   delexit();*		}*/	 		mrewind(tokfile);	}/*	mfclose(strfile);*	strfile = mfopen(strfilename,a_out_file->vrefnum, "r");*/	mrewind(strfile);}void pass2(void){#ifdef DEBUG	if (debug)		iowprintf("\n\n\n\t\tPASS 2\n\n\n\n");#endif DEBUG	passno = 2;	lineno = 1;	dotp = &usedot[0];	txtfil = usefile[0];	/* already opened (always!) */	relfil = 0;		/* outrel takes care of the rest */	initoutrel();	inittokfile();	yyparse();		/* dumpsymtab(); */	closetokfile();}void fillsegments(void){	long	locindex;	/*	 *	Round text and data segments to FW by appending zeros	 */	for (locindex = 0; locindex < NLOC + NLOC; locindex++) {		if (usefile[locindex]) {			txtfil = usefile[locindex];			dotp = &usedot[locindex];			while (usedot[locindex].e_xvalue & FW)				outb(0);		}	}}void reloc_syms(void){	/*	 *	Move the relocation information to a.out	 *	a_out_off is the offset so far:	 *	exec + text segments + data segments	 */	relocfile = (BFILE *)ClearCalloc(1,sizeof(BFILE));#ifdef DEBUG	iowprintf("relocfile in reloc_syms() allocated at %x for %d\n",relocfile,sizeof(BFILE));#endif	bopen(relocfile, a_out_off);	a_out_off += closeoutrel(relocfile);	hdr.a_trsize = trsize;	hdr.a_drsize = drsize;	if (readonlydata) 	{		hdr.a_text += hdr.a_data;		hdr.a_data = 0;		hdr.a_trsize += hdr.a_drsize;		hdr.a_drsize = 0;	}	/*	 *	Output the symbol table and the string pool	 *	 *	We must first rewind the string pool file to its beginning,	 *	in case it was seek'ed into for fetching ascii and asciz	 *	strings.	 */	mfseek(strfile, 0, 0);	symwrite(relocfile);	#ifdef hacky_debugging_codefor(i=0;i!=tsize;i++)		dummy[i] = (bit_map[i>>3] & (1 << (i & 0x7)))?'1':'0';	dummy[i]=0;#endif	bwrite( bit_map, (tsize+7)>> 3, relocfile );}void fix_a_out(void){	struct exec_struct temp;	/* for reversing words on the mac */		if (mlseek(a_out_file->fd, 0L, 0) == -1)		yyerror("Reposition for header rewrite fails");	temp.a_magic = REVLONG( hdr.a_magic );	temp.a_text = REVLONG( hdr.a_text );	temp.a_data = REVLONG( hdr.a_data );	temp.a_bss = REVLONG( hdr.a_bss );	temp.a_syms = REVLONG( hdr.a_syms );	temp.a_entry = REVLONG( hdr.a_entry );	temp.a_trsize = REVLONG( hdr.a_trsize );	temp.a_drsize = REVLONG( hdr.a_drsize );	if (mwrite(a_out_file->fd, (char *)&temp, sizeof (struct exec_struct)) < 0)		yyerror("Rewrite of header fails");	mclose( a_out_file );}void delexit(void){	iowprintf( "Assembly aborted due to errors\n");	myexit(1);}void delete(void){	if (useVM == 0 || tokfilename[0])	{		mfclose( tokfile );		munlink(tokfilename,last_a_out_file.vrefnum);	}	if (strfilename[0])	{		mfclose( strfile );		munlink(strfilename,last_a_out_file.vrefnum);	}}void sawabort(void){	aprintf("Asked to abort");/*	while (fillinbuffer() != (char *)0)		continue;  This makes no sense as fillinbuffer does not return a value*/	myexit(1);	/*although the previous pass will also exit non zero*/}void panic(	char	*fmt,	...	/*VARARGS 1*/){unsigned long * a1 = (unsigned long *) &fmt + 1;unsigned long * a2 = (unsigned long *) &fmt + 2;unsigned long * a3 = (unsigned long *) &fmt + 3;unsigned long * a4 = (unsigned long *) &fmt + 4;	aprintf(fmt, *a1, *a2, *a3, *a4);	/*	 *	noramlly we would want to cause	 *	a core dump here.  NOT with the	 *	mac though...	 *	 *	abort();	 *	 */	myexit( -1 );}void myexit(long n ){	/* called for errors that would cause the assembler to give up */	if(a_out_file != 0)	{		mclose(a_out_file);		munlink(last_a_out_file.name,last_a_out_file.vrefnum);;	}	delete(); /*removes tmp files*/	longjmp( env, n );}