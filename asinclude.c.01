/*******************************************************************  File Name : asinclude.c*  Goal : Integrate all the include instruction available inside *		OrgFile to build th CmplFile => Algo :*			- Sequential reading of the original file to find**  Rem : A comment will be tolerate on the same line than an include*		instruction, but nothing else.*/#include <ctype.h>#include <String.h>#include <Strings.h>#include <StdLib.h>#include "mstdio.h"#include "iow.h"#include  "asinclude.h"#define True   -1#define False   0#define EndOfStr  '\0'#define LongNormStr  255#define LimStackIncl  20    /* Form 0 to 20 */#define StrDirectIncl ".include"     /* String used inside the assembler program *//* Stack of the source file identifier, to follow the complete   *//* program script, given by the main file and all the associate  *//* includes. The main file is accessible with the index == 0 	  */ typedef  struct  {  		int  IndexCF;							/* Index current file, is alway */													/* on the file currently read.  */															M_FILE  FileId[LimStackIncl];    /* File identifier */			} TStackFId;	/*******************************************************************  Copy the second Id to the first.*/void  CopySecToFirst(M_FILE  *First, M_FILE  *Second){  First->_cnt = Second->_cnt;  First->_ptr = Second->_ptr;  First->_base = Second->_base;  First->_bufsiz = Second->_bufsiz;  First->_flag = Second->_flag;  First->_file = Second->_file;  First->vrefnum = Second->vrefnum;  strcpy (First->name,Second->name);} /* CopySecToFirst */	/*******************************************************************/void  PrintIdFile(  M_FILE	*First){  wprintf ("################\n");  wprintf ("%d %s", First->_cnt, "\n");  wprintf ("%c %s", First->_ptr, "\n");  wprintf ("%c %s", First->_base, "\n");  wprintf ("%d %s", First->_bufsiz, "\n");  wprintf ("%d %s", First->_flag, "\n");  wprintf ("%d %s", First->_file, "\n");  wprintf ("%d %s", First->vrefnum, "\n");  wprintf ("%s %s", First->name, "\n");  wprintf ("################\n");  } /* PrintIdFile *//*******************************************************************  Replace all the include instructions with the content of the*  pointed file. *  Return true if everythings are ok, or false if there is a*  problem.**  IdCmplFile : Identificator for the complete file before and after*					absorbtion of the includes.*  IdOrgFile : Identificator for the original file, with include *					instructions.   *  NameCmplFile : Name of the complete file, given back because we*					need it to open it again after creation (mopen_na),*					and we need this string because the closure of this*					file make the  IdCmplFile->name not available.**/Boolean  IntegrateTheInclude(  M_FILE  *IdCmplFile,       M_FILE  *IdOrgFile,      char    *NameCmplFile){   /* VAR */	char  CurrentStr[LongNormStr];   int  	CountLine;		TStackFId  StackFId;  /* Stack of file identifier */	char  CurStringCF[LongNormStr];  /* Current string of the current file */	char  CurStringOC[LongNormStr]; 	/* Current string of the current file */												/* Outside any Comments or Quotation  */													Boolean  InsideComOn;  	/* On if the end of the precedent string */									/* was inside a comment. */																			Boolean  InsideQuoOn;  	/* On if the end of the precedent string */									/* was inside a quotation mark. */										Boolean	TouchQuo;		/* True if we met one or many " on a line */											Boolean  ContinueFileSwitch;  																			M_FILE IdCurFile;  		/* Identifier of the current file */	M_FILE *PtIdCurFile;  		/* Identifier of the current file */		char  *ResultGetCurS;  	/* Result get current string (Null or not) */	char  NewFileName[64];  /* New current file name associate with an include */	Boolean  OutBecNewIncl; /* Go out because a new include has been found */	   /* BEGIN */	wprintf ("@@@ start IntegrateTheInclude\n");		/* @@ */  PrintIdFile (IdOrgFile);   IdCmplFile = mfopen("TempX71X",IdOrgFile->vrefnum,"w");   if  (IdCmplFile == NULL)	{		wprintf ("can't open IdCmplFile\n");		wprintf ("%s %s","Orig file name = ",IdOrgFile->name);		wprintf ("%s %d", "Orig file vrefnum = ", IdOrgFile->vrefnum);		return (False);	}	else	{	   /***********************************		*  Situation :		* 	- OrgFile open to be read.		*	- CmplFile open to be written.		*/				/* Init the stack of file identifiers */		StackFId.IndexCF = 0;		CopySecToFirst (&StackFId.FileId[0],IdOrgFile);		/* @@ */  PrintIdFile (&StackFId.FileId[0]);		CopySecToFirst (&IdCurFile,IdOrgFile);							/*****************************************************/		/* Loop used to switch from one file to an other one */		ContinueFileSwitch = True;		ResultGetCurS =  mfgets (CurStringCF,LongNormStr,&IdCurFile);      while (ContinueFileSwitch)		{ /* File switch */				wprintf ("@@ start the loop ContinueFileSwitch\n");				/**************************************************************/		/* Read the current stringCF accross the current file 		  */		/* until its end or an include. 										  */		/* Care about comment (like in C)  and string (like in C) ""  */		CountLine = 1;		InsideComOn = False;		InsideQuoOn = False;		OutBecNewIncl = False;				wprintf ("%s %d %s", "@@ ResultGetCurS ", ResultGetCurS, "\n");		wprintf ("%s %d %s", "@@ OutBecNewIncl ", OutBecNewIncl, "\n");   	while (  (ResultGetCurS != NULL)  &&  !OutBecNewIncl )   	{		   wprintf ("@@ Inside loop current file\n");						TouchQuo = False;			if  (PartOutsideCom(CurStringOC,&InsideComOn,&InsideQuoOn,&TouchQuo,CurStringCF))			{			   wprintf ("@@ outside PartOutsideCom\n");						   	/* CurStringOC has been purged of any comment */							if  ( (!InsideQuoOn) && (!TouchQuo) && FoundIncludeLine (NewFileName,CurStringOC,&InsideQuoOn) )				{				   wprintf ("@@ Found an include line\n");					wprintf ("%s %s %s", "@@New filename after Fincl ", NewFileName, "\0");									   /* Open the new file, load the IdStack and */					/* actualize the current variables.			 */					PtIdCurFile = mfopen (NewFileName,IdCurFile.vrefnum,"r");					if  (PtIdCurFile != NULL)					{						OutBecNewIncl = True;						CopySecToFirst (&IdCurFile,PtIdCurFile);				   }					else					  wprintf ("%s %s %s %d %s","Can't open ",NewFileName," line ",CountLine,"\n");				}				else  				  /* Put the current string inside the complete file    */				  /* => the complete file would appear with no comment. */				  mfputs (CurStringOC,IdCmplFile);			}			/* else : don't write the comment */						ResultGetCurS =  mfgets (CurStringCF,LongNormStr,&IdCurFile);						wprintf ("Just AFTER the CURRENT READING PART\n");			/* @@ */  PrintIdFile (&IdCurFile);		   ++CountLine;   /* line of the current file */			   	}; /* Loop on current file */						/* Adapt for (and do) current file switching */		if  (OutBecNewIncl)		{			if  (StackFId.IndexCF < LimStackIncl)			{				++StackFId.IndexCF;				CopySecToFirst (&StackFId.FileId [StackFId.IndexCF],&IdCurFile);			}			else			  wprintf ("%s %s %d %s", "To many include :", " line ", CountLine, "\n");			}		else  /* Out because end of file */		{  			/* Close the present file and come back to the actual */			if  (StackFId.IndexCF > 0)			{				mfclose (&StackFId.FileId [StackFId.IndexCF]);				wprintf ("%s %s %s", "@@ just close ", StackFId.FileId [StackFId.IndexCF].name, "\n");				--StackFId.IndexCF;				CopySecToFirst (&IdCurFile,&StackFId.FileId [StackFId.IndexCF]);																wprintf ("Just BEFORE the CURRENT READING PART\n");				/* @@ */  PrintIdFile (&IdCurFile);								ResultGetCurS =  mfgets (CurStringCF,LongNormStr,&IdCurFile);																if  (ResultGetCurS == NULL)				{					wprintf ("@@ Null just after an include !!! \n");					/* @@ */  PrintIdFile (&IdCurFile);					wprintf ("%s %d %s", "@@ StackFId.IndexCF ", StackFId.IndexCF, "\n");					wprintf ("%s %s %s", "@@ IdCurFile.name ", IdCurFile.name, "\n");					wprintf ("%s %s %s", "@@ StackFId.FileId.name ", StackFId.FileId[StackFId.IndexCF].name, "\n");				}								}			else  /* else : end of the problem */			  ContinueFileSwitch = False;					}				}  /* File switch */				/* give back the name of the complete file and close it */			strcpy (NameCmplFile,IdCmplFile->name);		mfclose (IdCmplFile);		return (True);	}}  /* IntegrateTheInclude *//*******************************************************************  Effect : **  - If the string is a complete comment (no instruction on*    the line)  by itself, the function will be False and no *    string will be returned.*  - If the string has a part of comment and a part of*    instruction, the function will be true and a string*    holding the instruction part will be returned.*  *	CurPS : Current purged string from any comment, returned.**  InsideComOn : True if we are inside a comment, in relation*			with the position of the character index of the string, for*			the outside, keep the value it had on the last character.**  InsideQuoOn : Idem than for comment but don't influence the result*  		of the function except for itself, in use for outside to detect*			an improbable include inside some quotation marks.** 	TouchQuo : True if we touched the InsideQuoOn on the line.**  CurOS : Current original string.**/Boolean  PartOutsideCom(	char  	*CurPS,	Boolean 	*InsideComOn,	Boolean 	*InsideQuoOn,	Boolean  *TouchQuo,	char    	*CurOS){	/* VAR */	int	IndxOS;		/* Index char of the original string */	int   IndxPS;		/* Index char of the purged string */	char  OldChar;		/* Old character */	char  CurChar;		/* Current character */   		/* BEGIN */		wprintf ("@@ Start PartOutsideCom\n");		*TouchQuo = False;			OldChar = EndOfStr;	CurChar = EndOfStr;	if  (CurOS[0] != EndOfStr)	{		OldChar = CurOS[0];		CurChar = CurOS[1];   }	IndxOS = 1;	IndxPS = 0;	while  (OldChar != EndOfStr)	{				if  (*InsideComOn)  		{			/* Look for a end of comment */			if  (  (OldChar == '*')  &&  (CurChar == '/')  )			{				*InsideComOn = False;								/* Jump the / */				OldChar = CurChar;				++IndxOS;				CurChar = CurOS[IndxOS];							}		   /* And don't write anything inside CurPS */		}		else		{					/* We have only to care about the " outside comment */			if  (CurChar == '"')			{				*InsideQuoOn = !(*InsideQuoOn);				*TouchQuo = True;			}									if  (*InsideQuoOn)			{									CurPS[IndxPS] = OldChar;				++IndxPS;			}			else			{				if  (  (OldChar == '/')  &&  (CurChar == '*')  )					*InsideComOn = True;				else				{					/* We are outside any comment => can COPY the string */					CurPS[IndxPS] = OldChar;					++IndxPS;				}			}					}						OldChar = CurChar;		++IndxOS;		CurChar = CurOS[IndxOS];	}		CurPS[IndxPS] = EndOfStr;		if  (IndxPS != 0) 		return (True);	else		return (False);  	}  /* PartOutsideCom *//******************************************************************* True if a real include directive has been found inside. *   NewFName   : File name given with the include instruction *   CurPS   	: Current purged string free of any comment*	 QuotaOn		: In or out any quotation, to be able to eliminate*					  an include inside some ""*/Boolean  FoundIncludeLine(  char  *NewFName,  char  *CurPS,  Boolean *QuotaOn){	/* VAR */	int  StartSubS;  	/* Start of the substring */ 	int  IndxPS;	 	/* Index purged string */	int  IndxFN;		/* Index file name */	char CpyStrIncl[64];  			/* BEGIN */	strcpy (CpyStrIncl,StrDirectIncl);	wprintf ("%s %s %s", "@@ CurPS == ", CurPS, "\n");		if  (GiveStartSubS (&StartSubS,CurPS,CpyStrIncl))	{		   wprintf ("@@ found StrDirectIncl\n");			/* Look for the filename indicated */		IndxPS = StartSubS + strlen(StrDirectIncl);				/* Jump the white */		while  ( (CurPS[IndxPS] == ' ')  ||  (CurPS[IndxPS] == '\t') )			++IndxPS;				/* Memorise the file name until "white" */		IndxFN = 0;		while  ( (CurPS[IndxPS] != ' ') && (CurPS[IndxPS] != '\n') &&\					(CurPS[IndxPS] != '\r') && (CurPS[IndxPS] != '\t') )		{			NewFName [IndxFN] = CurPS[IndxPS];			++IndxFN;			++IndxPS;		};				NewFName [IndxFN] = EndOfStr;				wprintf ("%s %s %s", "@@New filename inside Fincl", NewFName, "\n");		   return (True);	}	else	{		wprintf ("@@ Didn't find StrDirectIncl\n");		return (False);	}}  /* FoundIncludeLine *//******************************************************************* True if the string2 is include inside the string1 and* give back the starting position of the substring.* Not working if s2 is NULL.*/Boolean  GiveStartSubS(	int   *StartSS,	char	*String1,	char 	*String2){	/* VAR */	int	LimStartSS;	int   IndxS1;	int   IndxS2;	Boolean  FoundSS;   /* Found sub string */				/* BEGIN */		wprintf ("@@ Start GiveStartSubS\n");	wprintf ("%s %s %s", "String1 ", String1, "\n");	wprintf ("%s %s %s", "String2 ", String2, "\n");			LimStartSS = strlen (String1) - strlen(String2);	wprintf ("%s %d %s","@@ LimStartSS ",LimStartSS,"\n");		*StartSS = 0;	FoundSS = False;	while ( (*StartSS < LimStartSS)  &&  !(FoundSS) )	{		while ( (*StartSS < LimStartSS) && (String1[*StartSS] != String2[0]) )			++(*StartSS);					if  (String1[*StartSS] == String2[0])		{		   wprintf ("@@ found first letter\n");			IndxS1 = *StartSS;			IndxS2 = 0;			do			{				++IndxS1;				++IndxS2;			} while ((String1[IndxS1] == String2[IndxS2]) && 						(String2[IndxS2] != EndOfStr ));									if  (String2[IndxS2] == EndOfStr)				FoundSS = True;			else			  ++(*StartSS);		}	}		return (FoundSS);	} /* GiveStartSubS */