#pragma segment ASIO#include <String.h>#include "mstdio.h"#include "as.h"#include "asio.h"#include "asmain.h"#include "asparse.h"/* *	Block I/O routines for logical I/O concurrently in *	more than one place in the same file. */long	biofd;			/* file descriptor for block I/O file */long	biobufsize;		/* optimal block size for I/O */off_t	boffset;		/* physical position in logical file */BFILE	*biobufs;		/* the block I/O buffers */#define	error(severity, message) \	{yyerror(message); if (severity) delexit();}void Flushfield(	register long n){	while (n>0) {		outb(bitfield);		bitfield >>= 8;		n -= 8;	}	bitoff=0;	bitfield=0;}/* *	Block I/O Routines */void bopen(	struct biobuf *bp,	off_t	off){	bp->b_ptr = bp->b_buf = ClearCalloc(1, biobufsize);#ifdef DEBUG	iowprintf("A buffer allocated by bopen at %x for %d\n",bp->b_buf,biobufsize);#endif	bp->b_nleft = biobufsize - (off % biobufsize);	bp->b_off = off;	bp->b_link = biobufs;	biobufs = bp;}long	bwrerror;void bwrite(	register char *p,	/*reg 11*/	register long cnt,	/*reg 10*/	register struct biobuf *bp  /*reg 9*/){	register long put;	/*reg 8*/	register char *to;	/*reg 7*/	#ifdef DEBUGiowprintf(  "Just entered bwrite\n" );#endiftop:#ifdef DEBUGiowprintf("At top of bwrite:cnt = %d,bp->b_nleft = %d,put=%d,bp=%d\n",			cnt,bp->b_nleft,put,bp);#endif	/* quick desparate hack */	if( bp->b_nleft < 0 || bp->b_nleft > biobufsize )		error( 1, "Buffer handler error" );;	if (cnt == 0)		return;	if (bp->b_nleft) {		put = bp->b_nleft;		if (put > cnt)			put = cnt;		bp->b_nleft -= put;		to = bp->b_ptr;#ifdef lint		*to = *to;#endif lint/*	 *	boy! talk about grotty!! They insert inline *	assembly language into their 'C' code (fast, but  *	YUCKY!).  We (of course) cant do that, so must *	write the blasted thing ourselves. *	 *	asm("movc3 r8,(r11),(r7)"); * */ /*		movc3( put, p, to ); */ 		memcpy( to, p,put);			bp->b_ptr += put;		p += put;		cnt -= put;		goto top;	}	if (cnt >= biobufsize) {		if (bp->b_ptr != bp->b_buf)			bflush1(bp);		put = cnt - cnt % biobufsize;		if (boffset != bp->b_off)			(void)mlseek(biofd, (long)bp->b_off, 0);		if (mwrite(biofd, p, put) != put) {			bwrerror = 1;			error(1, "Output write error 1");		}		bp->b_off += put;		boffset = bp->b_off;		p += put;		cnt -= put;		goto top;	}	bflush1(bp);	goto top;}void bflush(void){	register struct biobuf *bp;		if (bwrerror)		return;	for (bp = biobufs; bp; bp = bp->b_link)	{				bflush1(bp);	}}void bflush1(	register struct biobuf *bp){	register long cnt = bp->b_ptr - bp->b_buf;	if (cnt <= 0)		return;	if (boffset != bp->b_off)		if( mlseek(biofd, (long)bp->b_off, 0) == -1 )				error( 1, "Seek in physical file error" );	if (mwrite(biofd, bp->b_buf, cnt) != cnt) {		bwrerror = 1;		error(1, "Output write error 2");			}	bp->b_off += cnt;	boffset = bp->b_off;	bp->b_ptr = bp->b_buf;	bp->b_nleft = biobufsize;}char bflushc(	register struct biobuf *bp,	char	c){	bflush1(bp);	return bputc(c, bp);}