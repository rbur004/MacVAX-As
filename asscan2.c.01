#pragma segment ASSCAN#include <CType.h>#include <String.h>#include "asscanl.h"#include "asparse.h"#include "aprintf.h"#include "iow.h"#include "asinclude.h"inttoktype	oval = NL;#define	ASINBUFSIZ	4096char	inbufunget[8];char	inbuffer[ASINBUFSIZ];char	*Ginbufptr = inbuffer;long	Ginbufcnt = 0;long	scannerhadeof;extern long curr_in_fd;/******************************************* To catch the file name associate with * the .file compiler instrc. */char	VectInclFileName [IndxMaxIFN-1][32];   /* Vector */int		CountCharIFN = 0;  /* To fill a string */int		IndxVectFN = 0;	   /* Index of the vector *//*******************************************//*long skip_spaces() {char ch; 	while((type+1)[ch = getchar()] == SP )		; 	return (ungetc( ch ) );}*/void fillinbuffer(void){		long	nread;		long	goal;		long	got;#ifdef DEBUG	wprintf("fillinbuffer()\n");#endif	nread = 0;	if (scannerhadeof == 0)	{		goal = sizeof(inbuffer);		do 		{			got = mread(curr_in_fd, inbuffer + nread, goal);			if (got == 0)				scannerhadeof = 1;			if (got <= 0)				break;			nread += got;			goal -= got;		} while (goal);	}	else 	{		scannerhadeof = 0;	}	/*	 *	getchar assumes that Ginbufcnt and Ginbufptr	 *	are adjusted as if one character has been removed	 *	from the input.	 */	if (nread == 0)	{		inbuffer[0] = EOFCHAR;		nread = 1;	}	Ginbufcnt = nread - 1;	Ginbufptr = inbuffer + 1;}void scan_dot_s(	struct tokbufdesc *bufferbox){	reg	char	*inbufptr;	reg	long	inbufcnt;	reg	long	ryylval;	/* local copy of lexical value */	extern	long	yylval;		/* global copy of lexical value */	reg	long	val;		/* the value returned */		long	i;		/* simple counter */	reg	char	*rcp;			long	ch;		/* treated as a character */		long	ch1;		/* shadow value */		struct 	symtab	*op;	reg	ptrall	bufptr;		/* where to stuff tokens */		ptrall	bufub;		/* where not to stuff tokens */		long	intval;		/* value of long */		long	linescrossed;	/* when doing strings and comments */		struct	Opcode		opstruct;	reg	long	strlg;		/* the length of a string */		char mch;#ifdef DEBUG	wprintf("scan_dot_s()\n");#endif	(bytetoktype *)bufptr = (bytetoktype *) & (bufferbox->toks[0]);		(bytetoktype *)bufub = &(bufferbox->toks[AVAILTOKS]);		MEMTOREGBUF;	if (newfflag){		newfflag = 0;		ryylval = (long)savestr(newfname, strlen(newfname)+1, STR_BOTH);		ptoken(bufptr, IFILE);				ptoken(bufptr, STRING);		pptr(bufptr, ryylval);		ptoken(bufptr, ILINENO);		ptoken(bufptr, INT);		pint(bufptr,  1);	}	while (bufptr < bufub){   loop:   		ryylval = (type+1)[ch = getchar()];		 switch(ryylval) {	case SCANEOF:	endoffile: 		inbufptr = 0;		ptoken(bufptr, PARSEEOF);		goto done;	case DIV:		/*process C style comments*/		if ( (ch = getchar()) == '*') {  /*comment prelude*/			long	incomment;			linescrossed = 0;			incomment = 1;			ch = getchar();	/*skip over the * */			while(incomment)			{				switch(ch){				case '*':					ch = getchar();					incomment = (ch != '/');					break;				case '\n':					scanlineno++;					linescrossed++;					ch = getchar();					break;				case EOFCHAR:					goto endoffile;				default:					ch = getchar();					break;				}			}			val = ILINESKIP;			ryylval = linescrossed;			goto ret;		} else {	/*just an ordinary DIV*/			ungetc(ch);			val = ryylval = DIV;			goto ret;		}	case SH:		if (oval == NL){			/*			 *	Attempt to recognize a C preprocessor			 *	style comment '^#[ \t]*[0-9]*[ \t]*".*"			 */			ch = getchar();	/*bump the #*/			while (INCHARSET(ch, SPACE))			{					ch = getchar();/*bump white */			}				if (INCHARSET(ch, DIGIT)){				intval = 0;				while(INCHARSET(ch, DIGIT))				{						intval = intval*10 + ch - '0';					ch = getchar();				}				while (INCHARSET(ch, SPACE))				{						ch = getchar();				}				/* @@ */				if (ch == '"'){					ptoken(bufptr, ILINENO);					ptoken(bufptr, INT);					pint(bufptr, intval - 1);					ptoken(bufptr, IFILE);											/*					 *	The '"' has already been					 *	munched					 *						 *	eatstr will not eat					 *	the trailing \n, so					 *	it is given to the parser					 *	and counted.					 */					goto eatstr;				}			}		}		/*		 *	Well, its just an ordinary decadent comment		 */		while ((ch != '\n') && (ch != EOFCHAR)) 		{			ch = getchar();					}		if (ch == EOFCHAR)			goto endoffile;		val = ryylval = oval = NL;		scanlineno++;		goto ret;	case NL:		scanlineno++;		val = ryylval;		goto ret;	case SP:		oval = SP;	/*invalidate ^# meta comments*/		goto loop;	case REGOP:		/* % , could be used as modulo, or register*/		ch = getchar();		if (INCHARSET(ch, DIGIT)){			ryylval = ch-'0';			if (ch=='1') {				if (INCHARSET( (ch = getchar()), REGDIGIT))					ryylval = 10+ch-'0';				else					ungetc(ch);			}			/*			 *	God only knows what the original author			 *	wanted this undocumented feature to			 *	do.			 *		%5++ is really  r7			 */			while(INCHARSET( (ch = getchar()), SIGN)) 			{				if (ch=='+')					ryylval++;				else					ryylval--;			}			ungetc(ch);			val = REG;		} else {			ungetc(ch);			val = REGOP;		}		goto ret;	case ALPH:		ch1 = ch;		if (INCHARSET(ch, SZSPECBEGIN)){			if( (ch = getchar()) == '`' || ch == '^'){				ch1 |= 040;	/*convert to lower*/				switch(ch1){				case 'b':	ryylval = 1;	break;				case 'w':	ryylval = 2;	break;				case 'l':	ryylval = 4;	break;				default:	ryylval = d124;	break;				}				val = SIZESPEC;				goto ret;			} else {				ungetc(ch);				ch = ch1;	/*restore first character*/			}		}		rcp = yytext;		do {			if (rcp < &yytext[NCPName])				*rcp++ = ch;		} while (INCHARSET ( (ch = getchar()), ALPHA | DIGIT));		*rcp = '\0';		while (INCHARSET(ch, SPACE))		{				ch = getchar();		}		ungetc(ch);			switch((op = *lookup(1))->s_tag){		case 0:		case LABELID:			/*			 *	Its a name... (Labels are subsets of name)			 */			ryylval = (long)op;			val = NAME;			break;		case INST0:		case INSTn:		case IJXXX:			opstruct.Op_popcode = ( (struct instab *)op)->i_popcode;			opstruct.Op_eopcode = ( (struct instab *)op)->i_eopcode;			val = op->s_tag;			break;		default:			ryylval = ( (struct instab *)op)->i_popcode;			val = op->s_tag;			break;		}		goto ret;	case DIG:		/*		 *	restore local inbufptr and inbufcnt		 */		REGTOMEMBUF;		val = number(ch);		MEMTOREGBUF;		/*		 *	yylval or yybignum has been stuffed as a side		 *	effect to number(); get the global yylval		 *	into our fast local copy in case it was an INT.		 */		ryylval = yylval;		goto ret;	case LSH:	case RSH:		/*		 *	We allow the C style operators		 *	<< and >>, as well as < and >		 */		if ( (ch1 = getchar()) != ch)			ungetc(ch1);		val = ryylval;		goto ret;	case MINUS:		if ( (ch = getchar()) =='(')			ryylval=val=MP;		else {			ungetc(ch);			val=MINUS;		}		goto ret;	case SQ:		if ((ryylval = getchar()) == '\n')			scanlineno++;		/*not entirely correct*/		val = INT;		goto ret;	case DQ:	   eatstr:		linescrossed = 0;		for (strlg = 0; /*VOID*/; strlg++)		{						ch = getchar();										/***************************************************			* ### take the file name in relation with a .file  			* compiler directive; to fix an old bug. This option 			* is in use when the compiler deal with an appended 			* file coming from many other include files.			*/						VectInclFileName[IndxVectFN][CountCharIFN] = ch;			++CountCharIFN;						/* Ponctuate the string */			if  (VectInclFileName[IndxVectFN][CountCharIFN-1] == '"')			{				/* Ponctuate the string */				VectInclFileName [IndxVectFN] [CountCharIFN-1]  = '\0'; 								wprintf ("%s %s %s", "Load file name vect with : ", VectInclFileName[IndxVectFN], "\n");												CountCharIFN = 0;  /* To start the next string */								if  (IndxVectFN < IndxMaxIFN)					++IndxVectFN;				else				{				 	wprintf ("Too many  '.file'  in the appended file\n");					wprintf ("therefore : the errors messages will have\n");					wprintf ("an incorrect file name identification\n");				}		    }			/*			***************************************************/						switch(ch)			{		    case '"':				goto tailDQ;		    default:		    stuff:				mputc(ch, strfile);				break;		    case '\n':			{			long hold_lineno = lineno; /*need to fudge this so yywarning can give the correct line number*/				lineno = scanlineno;				yyerror("New line in a string constant. "); /*was yywarning. Now not letting strings span lines*/				lineno = hold_lineno;				ungetc('\n'); /*new line not part of string*/				goto tailDQ;  /*Assume End of String and exit*//*								scanlineno++;				linescrossed++;				ch = getchar();				switch(ch)				{				case EOFCHAR:					mputc('\n', strfile);					ungetc(EOFCHAR);					goto tailDQ;				default:					ungetc(ch);					ch = '\n';					goto stuff;				}*/				break; 			}							case EOFCHAR: /*Check for EOF. They seem to have forgotten this could happen*/				mputc('\n', strfile);				ungetc(EOFCHAR);				goto tailDQ;				aprintf("Not possible to reach this statement: 3");				break;	/*never reach this break*/		    case '\\':				ch = getchar();		/*skip the '\\'*/				if ( INCHARSET(ch, BSESCAPE))				{					switch (ch)					{				  	case 'b':  ch = '\b'; goto stuff;				 	 case 'f':  ch = '\f'; goto stuff;				  	case 'n':  ch = '\n'; goto stuff;				 	 case 'r':  ch = '\r'; goto stuff;				 	 case 't':  ch = '\t'; goto stuff;					}				}				if ( !(INCHARSET(ch, OCTDIGIT)) ) 					goto stuff;				i = 0;				intval = 0;				while ( (i < 3) && (INCHARSET(ch, OCTDIGIT)))				{					i++;					intval <<= 3;					intval += ch - '0';					ch = getchar();				}				ungetc(ch);				ch = (char)intval;				goto stuff;		    }		}  /* @@ end for */					tailDQ: ;		/*		 *	account for any lines that were crossed		 */		if (linescrossed){			ptoken(bufptr, ILINESKIP);			pint(bufptr, linescrossed);		}		/*		 *	Cheat: append a trailing null to the string		 *	and then adjust the string length to ignore		 *	the trailing null.  If any STRING client requires		 *	the trailing null, the client can just change STRLEN		 */		mputc(0, strfile);		ryylval = (long)savestr((char *)0, strlg + 1, STR_FILE);		val = STRING;		((struct strdesc *)ryylval)->sd_strlen -= 1;		goto ret;	case XOR:		/* MAC port: add register masks */		/* convert to lower, is it a mask? */		if( tolower( mch = getchar()) != 'm' )  		{			/* NO!  just an ordinary XOR */			ungetc( mch );			val = ryylval;			goto ret;		}		/* it is the start of a mask, */		val = MASK;		goto ret;					case BADCHAR:	   badone:		linescrossed = lineno;		lineno = scanlineno;		yyerror("Illegal character mapped: %d, char read:(octal) %o",			ryylval, ch);		lineno = linescrossed;		val = BADCHAR;		goto ret;	default:		val = ryylval;		goto ret;	}	/*end of the switch*/	/*	 *	here with one token, so stuff it	 */   ret:	  	oval = val;	ptoken(bufptr, val);	switch(val){		case	ILINESKIP:				pint(bufptr, ryylval);				break;		case	SIZESPEC:				pchar(bufptr, ryylval);				break;		case	BFINT:	plong(bufptr, ryylval);				break;		case	INT:	plong(bufptr, ryylval);				break;		case 	BIGNUM:	pnumber(bufptr, yybignum);				break;		case	STRING:	pptr(bufptr, (long)(char *)ryylval);				break;		case	NAME:	pptr(bufptr, (long)(struct symtab *)ryylval);				break;		case	REG:	pchar(bufptr, ryylval);				break;			case	INST0:		case	INSTn:				popcode(bufptr, opstruct);				break;		case 	IJXXX:				popcode(bufptr, opstruct);				pptr(bufptr, (long)(struct symtab *)symalloc());				break;		case	ISTAB:		case	ISTABSTR:		case	ISTABNONE:		case	ISTABDOT:		case	IALIGN:				pptr(bufptr, (long)(struct symtab *)symalloc());				break;	/*	 *	default:	 */	 }	 builtval: ;  }			/*end of the while to stuff the buffer*/   done:	bufferbox->tok_count = (bytetoktype *)bufptr - &(bufferbox->toks[0]);	/*	 *	This is a real kludge:	 *	 *	We put the last token in the buffer to be  a MINUS	 *	symbol.  This last token will never be picked up	 *	in the normal way, but can be looked at during	 *	a peekahead look that the short circuit expression	 *	evaluator uses to see if an expression is complicated.	 *	 *	Consider the following situation:	 *	 *	.word	45		+	47	 *        buffer 1      |  buffer 0	 *	the peekahead would want to look across the buffer,	 *	but will look in the buffer end zone, see the minus, and	 *	fail.	 */	ptoken(bufptr, MINUS);	REGTOMEMBUF;}