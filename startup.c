#include <types.h>#include <SegLoad.h>#include <Files.h>#include <String.h>#include <Strings.h>#include <StdLib.h>#define _STARTUP_C_#include 	"macio.h"#include	"startup.h"#include 	"aprintf.h"#include 	"asmain.h"#include	"iow.h"#include 	"mstdio.h"#include 	"mmalloc.h"#pragma segment STARTUP#ifdef C68Kvoid process_finder_info(void){short message;	/*print or open?*/short count;	/*number of args*/short i;AppFile thefile;MFILE **fileinfo;OSErr error = 0;Handle argvx; Str255 argv0;short argv0_refnum;	GetAppParms(argv0,&argv0_refnum,&argvx);	GetVRefNum(argv0_refnum,&appl_vrefnum);	CountAppFiles(&message,&count);	if(message)	{		aprintf("No Print Option");		exit(0);	}	if( count > 0 )	{		if( ( fileinfo = (MFILE **) mcalloc(count,sizeof(MFILE) ) ) == 0 )		{			aprintf("Memory alloc failed.\nUnable to process args");			exit(0);		}		for(i = 1; i <= count; i++)		{			GetAppFiles(i, &thefile );			p2cstr(thefile.fName);			if(thefile.fType == 'TEXT')			{				if((fileinfo[num_files] = mopen_na((char *)&thefile.fName,thefile.vRefNum)) != 0)					num_files++;				else				{					error = 1;					break;				}			}			else			{				aprintf("File %s: type not 'TEXT' ", &thefile.fName);				error = 1;				break;			}		}		if(num_files)		{			if(error == 0)			{				//iowprintf ("Don't use the .include compiler directive\n");				vax_assemble( num_files, fileinfo,"file_name" );			}			for(i = 0 ; i < num_files; i++)				mclose(fileinfo[i]);		}	}}#elsevoid init_AE( void ){	AEInstallEventHandler(kCoreEventClass,  kAEOpenApplication,             	NewAEEventHandlerProc(AEOpenApplication),       nil,false);			// run	AEInstallEventHandler(kCoreEventClass,  kAEQuitApplication,			NewAEEventHandlerProc(AEQuitApplication),       nil, false);		// quit	AEInstallEventHandler(kCoreEventClass,  kAEOpenDocuments,        	NewAEEventHandlerProc(AEOpenDocument),    nil,false);				// open	AEInstallEventHandler(kCoreEventClass,  kAEPrintDocuments,              	NewAEEventHandlerProc(AEPrintHandler),     nil,false);				// (print)}/*        - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        AEOpenApplication                AppleEvent message saying that the application        has been opened with no documents.                - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/      pascal OSErr AEOpenApplication( 	AppleEvent *theAppleEvent, 	AppleEvent* reply, 	long refCon){        // I have yet to see the point in calling GetMissingParams.        /*!!NewDocument();*/        return( noErr );}/*        - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        AEQuitApplication                AppleEvent message telling this app to quit                Parameters:        - one, a boolean indicating whether or not to save          all documents        - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/      pascal OSErr AEQuitApplication( 	const AppleEvent *message, 	const AppleEvent *reply, 	long refcon )                   {extern Boolean 		DoneFlag; //defined in main.c	DoneFlag = true;    return( noErr );}/*        - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        DummyHandler        Used for Apple event handlers that need to be handled        as a requirement, but don' actually do anything.        - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/      pascal OSErr AEPrintHandler( 	AppleEvent *theAppleEvent, 	AppleEvent *reply,	long refCon ){#pragma unused (theAppleEvent,reply,refCon)	aprintf("No Print Option");	return(errAEEventNotHandled);}/*        - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -        AEOpenDocument                Replaces calls to CountAppFiles and GetAppFiles since they're not        supported under Apple's universal headers 2.1 (glue was missing).                !! Also gives the user the ability to change the image while        !! the program is running whether this is useful or not.                --        An Apple Event containing a list (AEDescList) of aliases        to files. This function goes through the list        and extracts the aliases as FSSpecs (letting the Apple Event        Manager do the coercion).                This code was primarily pinched from '7Edit', an AppleEvent        example on the AppleEvent SDK                - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/      pascal OSErr AEOpenDocument( 	const AppleEvent *message, 	const AppleEvent *reply, 	long refcon ){#pragma unused (reply, refcon)long        index;long        itemsInList;AEKeyword   keywd;OSErr       result;AEDescList  docList;long        actSize;DescType    typeCode;FSSpec      theFSSpec;MFILE **fileinfo;OSErr error = 0;FInfo fndrInfo;int i;                	docList.dataHandle = nil;		/* Get the list descriptor */	result = AEGetParamDesc( message, keyDirectObject, typeAEList, &docList );	if( result != noErr )	    return( result );		/* Count how many elements there are */	result = AECountItems( &docList, &itemsInList);	if( result != noErr )	    return( result );			if( itemsInList > 0 )	{	    		if( ( fileinfo = (MFILE **) mcalloc(itemsInList, sizeof(MFILE) ) ) == 0 )		{			aprintf("Memory alloc failed.\nUnable to process args");			exit(0);		}		/* Now walk through the list extracting the elements */		for( index = 1; index <= itemsInList; index++ )		{		    result = AEGetNthPtr( &docList, index, typeFSS, &keywd, &typeCode,		                                              (Ptr)&theFSSpec, sizeof(theFSSpec), &actSize ) ;		    if( result == noErr )		    {				p2cstr(theFSSpec.name);				if((result = FSpGetFInfo(&theFSSpec, &fndrInfo)) == noErr)				{					if(fndrInfo.fdType == 'TEXT')					{						if((fileinfo[num_files] = mopen_na((char *)&theFSSpec.name,theFSSpec.vRefNum)) != 0)							num_files++;						else						{							error = 1;							break;						}					}					else					{						aprintf("File %s: type not 'TEXT' ", &theFSSpec.name);						error = 1;						break;					}				}				else				{					aprintf("File %s: Couldn't get Finder Info\n(err %d)", &theFSSpec.name, result);					error = 1;					break;				}		    }		}		if(num_files)		{			if(error == 0)			{				//iowprintf ("Don't use the .include compiler directive\n");				vax_assemble( num_files, fileinfo,"file_name");			}			for(i = 0 ; i < num_files; i++)				mclose(fileinfo[i]);		}	}		if( docList.dataHandle != nil )	    (void) AEDisposeDesc( &docList );	            	return( result );}#endif