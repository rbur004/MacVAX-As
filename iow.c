#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include	<toolutils.h>#include	<StdIO.h>#include "window.h"#include "iow.h"#include "VarArgs.h"#include "aprintf.h"#pragma segment IOWTEHandle TextH;void iow_click(	/*Handle clicks in the window*/	Point *p){#pragma unused(p)	SysBeep(5);}void iow_keypress(	/*Handles keypresses*/	long key){	iow_putchar(key);}void iow_undo_keypress(void){	SysBeep(5);}void update_IO_window(	/*Handles update events*/	void){	if( ((WindowPeek) (AsWindow->windowptr))->visible == false )		return;	TEUpdate(&(AsWindow->usable), TextH);}void iow_init(void){Rect	txRect;GrafPtr savePort;	GetPort(&savePort);		SetPort(AsWindow->windowptr);		txRect = AsWindow->usable;	 	InsetRect(&txRect, 4, 0);		TextH = TENew(&txRect, &txRect);	/* Not growable, so destRect == viewRect */		SetCtlMax(AsWindow->vScroll, (short)(*TextH)->nLines );		iow_grow();	SetPort(savePort);}void iow_scroll(	short dh,	short dv){		TEScroll(dh,dv,TextH);}void iow_grow(void){	(*TextH)->viewRect = AsWindow->usable;	AsWindow->lsize = (short)(*TextH)->lineHeight;	AsWindow->nlines = ((short)(*TextH)->viewRect.bottom - (short)(*TextH)->viewRect.top) / (short)(*TextH)->lineHeight;}static char iowpf_buff[1024];void iowprintf(	void *my_va_alist,...){my_va_list ap;char *fmt;long length;GrafPtr savePort;char *p;	GetPort(&savePort);	my_va_start(ap);		fmt = my_va_arg(ap, char *);		if(( length = vsprintf(iowpf_buff,fmt,ap)) < 0)		{			aprintf("error in wprintf");			return;		}	my_va_end(ap);		SetPort(AsWindow->windowptr);		if((*TextH)->teLength + length >= 32767)			return;		p = iowpf_buff;		while(length--)		{			TEKey (*p++, TextH);			SetCtlMax(AsWindow->vScroll, (short)(*TextH)->nLines );			scrollwithinput();		}	SetPort(savePort);}void iow_putchar(	char c){GrafPtr savePort;	GetPort(&savePort);		SetPort(AsWindow->windowptr);		if((*TextH)->teLength + 1 >= 32767)			return;		TEKey (c, TextH);		SetCtlMax(AsWindow->vScroll, (short)(*TextH)->nLines );		scrollwithinput();	SetPort(savePort);}	void activate_io_window(	/*Handles activate events*/	long is_active){#pragma unused(is_active)}void clear_io_window(	void){	TESetSelect(0,32767,TextH);	TEDelete(TextH);	ShowWindow(AsWindow->windowptr);	/* RTB 24/6/93 */}void scrollwithinput(void){short dh, dv;int line_depth;Point oldOrigin;short control_value = GetCtlValue(AsWindow->vScroll);short cur_line = (short)(*TextH)->nLines ;short num_slines = ((short)(*TextH)->viewRect.bottom - (short)(*TextH)->viewRect.top) / (short)(*TextH)->lineHeight;	if(cur_line == control_value + num_slines + 1)		SetCtlValue(AsWindow->vScroll, ++control_value );	else if(cur_line < control_value + 1)		SetCtlValue(AsWindow->vScroll, control_value = cur_line );	else if(cur_line > control_value + num_slines + 1)		SetCtlValue(AsWindow->vScroll, control_value = cur_line );	else		return;	line_depth = AsWindow->lsize;	/*depth in pixels of a line*/		oldOrigin = AsWindow->theOrigin;	/*note previous position*/	dh = 0;	AsWindow->theOrigin.v = control_value;	/*based on the position of */	dv = (short)(*TextH)->lineHeight * (oldOrigin.v - AsWindow->theOrigin.v);	/*calc amount needed to shift to new spot*/	TEScroll(dh, dv ,TextH);}