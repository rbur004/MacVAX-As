/**	File name : main.c*/#include	<types.h>#include	<quickdraw.h>#include	<toolutils.h>#include 	<files.h>#include	<fonts.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<OSEvents.h>#include	<resources.h>#include	<controls.h>#include	<memory.h>#include	<StdLib.h>#include	<macio.h>#define __MAIN_C_#include	"main.h"#include 	"window.h"#include 	"docmds.h"#include 	"iow.h"#include	"startup.h"#include 	"asmain.h"//extern _DataInit();static short menu_ids[4] = {	appleMenuid,	fileMenuid,	editMenuid,	TransferMenuid,};/* * Global Data objects, used by routines external to main(). */MenuHandle		MyMenus[menuCount]; 	/* The menu handles */Boolean 		DoneFlag;				/* Becomes TRUE when File/Quit chosen */void showAboutMeDialog(void);void appleDA (long theItem);#pragma segment Mainvoid main(void){EventRecord 			myEvent;long 					windownum;short 					myControl;long 					os_message;	/*	 * Initialization traps	 *///	UnloadSeg(_DataInit);	InitGraf(&qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();	FlushEvents(everyEvent, 0);	setupMenus();			/* Local procedure, below */	setupwindows();	assem_init();	DoneFlag = false;#ifdef C68K	process_finder_info();#else	init_AE();#endif#ifdef WANTTHIS		iowprintf ("\n*********************\n");	iowprintf ("* Vax Assembler 1.3 *\n");	iowprintf ("*********************\n");#endif		for ( ;; ) {		if (DoneFlag)		{			break;		/* from main event loop */		}		/*		 * Main Event tasks:		 */		SystemTask();		theActiveWindow = FrontWindow();				if (!GetNextEvent(everyEvent, &myEvent)) {			continue;		}		switch (myEvent.what) {			case mouseDown:				switch (FindWindow(myEvent.where, &whichWindow)) {					case inSysWindow:						SystemClick(&myEvent, whichWindow);						break;					case inMenuBar:						doCommand(MenuSelect(myEvent.where));						break;					case inDrag:						DragWindow(whichWindow, myEvent.where, &dragRect);						break;					case inGoAway:						if ((windownum = GetWRefCon(whichWindow) - AswID) >= 0 && windownum < NumWindows)							if (TrackGoAway(whichWindow, myEvent.where))								HideWindow(whichWindow);						break;											case inGrow:						if (whichWindow == theActiveWindow)						 	if ((windownum = GetWRefCon(whichWindow) - AswID) >= 0 && windownum < NumWindows)								GrowWnd(window_p + windownum ,myEvent.where);						else							SelectWindow(whichWindow);						break;											case inContent:						if (whichWindow != theActiveWindow && !(myEvent.modifiers & cmdKey)) 						{							SelectWindow(whichWindow);						} 						else if ((windownum = GetWRefCon(whichWindow) - AswID) >= 0 && windownum < NumWindows)						{	GlobalToLocal(&myEvent.where);							if (PtInRect(myEvent.where, &((window_p + windownum)->usable)) ) 								(window_p + windownum)->click_window(&myEvent.where);							else 							{								myControl = FindControl(myEvent.where, whichWindow, &whichControl);								switch(myControl) 								{								case inUpButton:										TrackControl(whichControl, myEvent.where , sScrollUpProc);										break;								case inDownButton:										TrackControl(whichControl, myEvent.where , sScrollDownProc);										break;								case inPageUp:										PageScroll(myControl, -(window_p + windownum)->nlines);										break;								case inPageDown:										PageScroll(myControl, (window_p + windownum)->nlines);										break;								case inThumb:										TrackControl(whichControl, myEvent.where , nil);										ScrollBits();										break;								}							}						}						break;					default:						break;				}/*endsw findwindow*/				break;			case keyDown:			case autoKey:					if (myEvent.modifiers & cmdKey)						doCommand(MenuKey(myEvent.message & charCodeMask));					else if ((windownum = GetWRefCon(theActiveWindow) - AswID) >= 0 && windownum < NumWindows)						if((window_p + windownum)->keypress)							(window_p + windownum)->keypress(myEvent.message & charCodeMask);				break;			case activateEvt:				if ((windownum = GetWRefCon((WindowPtr) myEvent.message) - AswID) >= 0 && windownum < NumWindows)					do_activate(window_p + windownum,myEvent.modifiers & activeFlag);				break;			case updateEvt:				if ((windownum = GetWRefCon((WindowPtr) myEvent.message) - AswID) >= 0 && windownum < NumWindows)					doupdate(window_p + windownum, 1L);				break;			case osEvt:				os_message = (myEvent.message >> 24) & 0xff;				if(os_message & suspendResumeMessage)				{					if(myEvent.message & resumeFlag )					{ 	/*resume*/						/*should check if clipboard has changed (if use private clip)*/						/*"if(myEvent.message & convertClipboardFlag)...;"						/*do_activate(theActiveWindow,0);*/					}					else /* suspend */					{					/*should save private clipboard*/					/*Set "background = true;" if we need to know this*/					/*deactivate whatever needs to be*/						/*do_activate(theActiveWindow,1);*/					}				}				break;						default:				break;					}/*endsw myEvent.what*/	}/*endfor Main Event loop*/			/*	 * No cleanup required, but if there was, it would happen here.	 */	exit( 0 );}/* * Demonstration of the segmenting facility: * * This code is execute-once, so we toss it in the "Initialize" * segment so that main() can unload it after it's called. * * There really isn't much here, but it demonstrates the segmenting facility. *//* * Set the segment to Initialize.  BEWARE: leading and trailing white space * would be part of the segment name! *//* * Set up the Apple, File, and Edit menus. * If the MENU resources are missing, we die. */void setupMenus(void){	long i;	/*	 * Set up the desk accessories menu.	 * The "About Sample..." item, followed by a grey line,	 * is presumed to be already in the resource.  We then	 * append the desk accessory names from the 'DRVR' resources.	 */	MyMenus[appleMenu] = GetMenu(appleMenuid);	AddResMenu(MyMenus[appleMenu], (ResType) 'DRVR');	InsertMenu(MyMenus[appleMenu],0);	for(i = 1; i < menuCount; i++)	{		MyMenus[i] = GetMenu(menu_ids[i]);		InsertMenu(MyMenus[i],0);	}	DrawMenuBar();}/* * Back to the Main segment. *//* * Display the About dialog. * Then wait for a click before returning. */void showAboutMeDialog(){	GrafPtr 	savePort;	DialogPtr	theDialog;	short		itemHit;	char 		*version = "?";	Handle		versionH;	GetPort(&savePort);	if((versionH = GetResource('VXAS',(short)0)) != (Handle)0)	{		HLock(versionH);		version = (char *) *versionH;	}	ParamText((void *)version,(void *)"",(void *)"",(void *)"");	theDialog = GetNewDialog(aboutMeDLOG, nil, (WindowPtr) -1);	SetPort(theDialog);	do {		ModalDialog(nil, &itemHit);	} while (itemHit == 0);	CloseDialog(theDialog);	if(versionH != (Handle)0)	{		HUnlock(versionH);		ReleaseResource(versionH);	}	SetPort(savePort);	return;}void appleDA (long theItem){	char				daName[256];	GrafPtr 			savePort;	getitem(MyMenus[appleMenu], theItem, daName);				GetPort(&savePort);				(void) opendeskacc(daName);				SetPort(savePort);}/* * Process mouse clicks in menu bar */void doCommand(	long	mResult){	/* VAR */	long 				theMenu, theItem;	char	NameComplFile[64];	short	VRefNumRet;			/* BEGIN */	theItem = LOWORD(mResult);	theMenu = HIWORD(mResult) - appleMenuid;		/* resource ID - 128 -> menunumber*/	switch (theMenu) {		case appleMenu:			if (theItem == aboutMeCommand)				showAboutMeDialog();			else appleDA (theItem);			break;		case fileMenu:			switch (theItem) {							case openCommand:					/* Start to ASSEMBLE after it */					file_open(NameComplFile,&VRefNumRet);					break;									case saveCommand:					file_save();					break;				case Clear_All:					clear_io_window();					break;				case quitCommand:					DoneFlag = true;			/* Request exit */					//fsdelete (NameComplFile,VRefNumRet);					break;				default:					break;			}			break;		case editMenu:			/*			 * If this is for a 'standard' edit item,			 * run it through SystemEdit first.			 * SystemEdit will return FALSE if it's not a system window.			 */			if ((theItem <= pasteCommand) && SystemEdit(theItem-1)) {				break;			}			/*			 * Otherwise, it's my window.			 * Handle Cut/Copy/Paste properly			 * between the TEScrap and the Clipboard.			 */			switch (theItem)			{				case undoCommand:					/* can't undo */					break;				case cutCommand:				case copyCommand:					if (theItem == cutCommand) {					/*	TECut(TextH);*/					} else {					/*	TECopy(TextH);*/					}					ZeroScrap();					/*TEToScrap();*/					break;				case pasteCommand:					/*TEFromScrap();*/					/*TEPaste(TextH);*/					break;				default:					break;			} /*endsw theItem*/			break;		case TransferMenu:			switch (theItem) 			{				case Simulator:					exec_simul();					break;				case Edit:					exec_edit();					break;				case Other:					exec_other();					break;				default:					break;			}			break;		default:			break;	}/*endsw theMenu*/	HiliteMenu(0);	return;}