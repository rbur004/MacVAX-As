#include "mstdio.h"#include <ctype.h>#include <String.h>#include <StdLib.h>#include "as.h"#include "asscan.h"#include "assyms.h"#include "unix.h"#include "bignum.h"#include "asparse.h"#include "asmain.h"#include "asio.h"/* *	Managers for chunks of symbols allocated from calloc() *	We maintain a linked list of such chunks. * */struct	allocbox	*allochead;	/*head of chunk list*/struct	allocbox	*alloctail;	/*tail*/struct	allocbox	*newbox;	/*for creating a new chunk*/struct	symtab		*nextsym;	/*next symbol free*/long			symsleft;	/*slots left in current chunk*/struct	symtab		**symptrs;struct	symtab		**symdelim[NLOC + NLOC +1];struct	symtab		**symptrub;/* *	Managers for the dynamically extendable hash table */struct	hashdallop	*htab;Iptr	*itab[NINST];	/*maps opcodes to instructions*//* *	Counts what went into the symbol table, so that the *	size of the symbol table can be computed. */long	nsyms;		/* total number in the symbol table */long	njxxx;		/* number of jxxx entrys */long	nforgotten;	/* number of symbols erroneously entered */long	nlabels;	/* number of label entries *//* *	Managers of the symbol literal storage. */struct	strpool		*strplhead = 0;#pragma segment ASSYMSvoid symtabinit(void){	allochead = 0;	alloctail = 0;	nextsym = 0;	symsleft = 0;	strpoolalloc();		/* get the first strpool storage area */	htab = 0;	htaballoc();		/* get the first part of the hash table */}/* *	Install all known instructions in the symbol table */void syminstall(void){	register	Iptr	ip;	register	struct	symtab	**hp;	register	char	*p1, *p2;	register	long	i;	for (i = 0; i < NINST; i++)		itab[i] = (Iptr*)BADPOINT;	for (ip = (Iptr)instab; FETCHNAME(ip)[0]; ip++) {		p1 = FETCHNAME(ip);		p2 = yytext;		while (*p2++ = *p1++);		hp = lookup(0);		/* 0 => don't install this*/		if (*hp==NULL) {			*hp = (struct symtab *)ip;			if (   (ip->s_tag!=INSTn)			    && (ip->s_tag!=INST0)			    && (ip->s_tag!=0))				continue; /* was pseudo-op */			if (itab[ip->i_eopcode] == (Iptr*)BADPOINT){				itab[ip->i_eopcode] =					(Iptr*)ClearCalloc(256, sizeof(Iptr));#ifdef DEBUG	iowprintf("itab[ip->i_eopcode] in syminstall() allocated at %x for %d\n",itab[ip->i_eopcode],256 * sizeof(Iptr));#endif				for (i = 0; i < 256; i++)					itab[ip->i_eopcode][i] =						(Iptr)BADPOINT;			}			itab[ip->i_eopcode][ip->i_popcode] = ip;		}	}}	/*end of syminstall*/#define ISLABEL(sp) \	(   (!savelabels) \	 && (sp->s_tag == LABELID) \	 && (STRPLACE(sp) & STR_CORE) \	 && (FETCHNAME(sp)[0] == 'L'))/* *	Assign final values to symbols, *	and overwrite the index field with its relative position in *	the symbol table we give to the loader. */extern struct exec hdr;void freezesymtab(void){	register	struct	symtab	*sp;				long	bs;	register	long	relpos = 0;	register	struct	symtab		*ubsp;	register	struct	allocbox	*allocwalk;	DECLITERATE(allocwalk, sp, ubsp)	{		if (sp->s_tag >= IGNOREBOUND)			continue; 		/*totally ignore jxxx entries */		/*		 *	Ignore stabs, but give them a symbol table index		 */		if (sp->s_type & STABFLAG)			goto assignindex;					/* RTB 11/3/93 */		/* deal with labels that have been defined as external but not actually 	*/		/* initiallised. Since we are doing away with the linker we must at least 	*/		/* allocate space for the identifiers. The reason we don't just make .comm 	*/		/* the same as .lcomm is because some C programmers might write code such as*/		/* the following:															*/		/*	int i;				(rather than 'extern int i')						*/		/*	int i = 3;																*/		/* Which could produce both a .comm as well as a definition. Goodness knows */		/* why anyone would want to write such rubbish in this ANSI age but mine not*/		/* to reason why...															*/				/* note this is identical code to .lcomm in asparse.c */		/* the subtle difference is that this occurs after pass1 when the label has */		/* had a chance to be defined by something else */		if (((sp->s_type&XTYPE)==XUNDEF) & (sp->s_type&XXTRN)) { /* undefined and external? */			/* iowprintf("defining %s\n",FETCHNAME(sp)); */			sp->s_type &= ~XTYPE;			sp->s_type |= XBSS;			sp->s_type |= XXTRN;	/* it is still external for consistency */		}				if ((sp->s_type&XTYPE)==XUNDEF)			sp->s_type = XXTRN+XUNDEF;		else if ((sp->s_type&XTYPE)==XDATA)			sp->s_value += usedot[sp->s_index].e_xvalue;		else if ((sp->s_type&XTYPE)==XTEXT)			sp->s_value += usedot[sp->s_index].e_xvalue;		else if ((sp->s_type&XTYPE)==XBSS) {			bs = sp->s_value;			sp->s_value = hdr.a_bss + datbase;			hdr.a_bss += bs;		}	   assignindex:		if (!ISLABEL(sp))			sp->s_index = relpos++;	}}/* *	For all of the stabs that had their final value undefined during pass 1 *	and during pass 2 assign a final value. *	We have already given stab entrys a initial approximation *	when we constsructed the sorted symbol table. *	Iteration order doesn't matter. */void stabfix(void){	register struct symtab *sp, **cosp;	register struct symtab *p;		SYMITERATE(cosp, sp){		if(sp->s_ptype && (sp->s_type & STABFLAG)) {				p = sp->s_dest;	/*  * STABFLOATING indicates that the offset has been saved in s_desc, s_other */			if(sp->s_tag == STABFLOATING) {			  sp->s_value = ( ( ((unsigned char) sp->s_other) << 16)  					| ( (unsigned short) sp->s_desc )  );			  sp->s_value = sp->s_value + p->s_value;			}			else sp->s_value = p->s_value;			sp->s_index = p->s_index;			sp->s_type = p->s_type;              		}	}}char *Calloc(	long	number,	long	size){	register	char *newstuff;	newstuff = sbrk(number*size);	if ((long)newstuff == -1){		yyerror("Ran out of Memory");		delexit();	}	return(newstuff);}char *ClearCalloc(	long	number, 	long	size){	register	char	*newstuff;		/* r11 */	register	long	length = number * size;	/* r10 */#ifdef lint	length = length;#endif length	newstuff = Calloc(number, size);#ifdef DEBUG	iowprintf("newstuff in ClearCalloc() allocated at %x for %d\n",newstuff,number * size);#endif/*	 *	boy! talk about grotty!! They insert inline *	assembly language into their 'C' code (fast, but  *	YUCKY!).  We (of course) cant do that, so must *	write the blasted thing ourselves. *	asm("movc5 $0, (r0), $0, r10, (r11)"); * *//*	movc5( 0, newstuff, 0, length, newstuff ); */	(void) memset( newstuff, '\0', length ); /*object seems to be to zero the newstuff block*/	return(newstuff);}struct symtab *symalloc(void){	if (symsleft == 0){		newbox = (struct allocbox *)ClearCalloc(1,ALLOCQTY);#ifdef DEBUG	iowprintf("newbox in symalloc() allocated at %x for %d\n",newbox,ALLOCQTY);#endif		symsleft = SYMDALLOP;		nextsym = &newbox->symslots[0];		if (alloctail == 0){			allochead = alloctail = newbox;		} else {			alloctail->nextalloc = newbox;			alloctail = newbox;		}	}	--symsleft;	++nsyms;	return(nextsym++);}void strpoolalloc(void){	register	struct	strpool	*new;	new = (struct strpool *)ClearCalloc(1, sizeof (struct strpool));#ifdef DEBUG	iowprintf("new in strpoolalloc() allocated at %x for %d\n",new,sizeof (struct strpool));#endif	new->str_nalloc = 0;	new->str_next = strplhead;	strplhead = new;}long symcmp(	struct symtab **Pptr,	struct symtab **Qptr){	register struct symtab *p = *Pptr;	register struct symtab *q = *Qptr;	if (p->s_index < q->s_index)		return(-1);	if (p->s_index > q->s_index)		return(1);	if (p->s_value < q->s_value)		return(-1);	if (p->s_value > q->s_value)		return(1);	/*	 *	Force jxxx entries to virtually preceed labels defined	 *	to follow the jxxxx instruction, so that bumping the	 *	jxxx instruction correctly fixes up the following labels	 */	if (p->s_tag >= IGNOREBOUND)	/*p points to a jxxx*/		return(-1);			if (q->s_tag >= IGNOREBOUND)		return(1);	/*	 *	both are now just plain labels; the relative order doesn't	 *	matter.  Both can't be jxxxes, as they would have different	 *	values.	 */	return(0);			}	/*end of symcmp*//* *	We construct the auxiliary table of pointers, symptrs and *	symdelim *	We also assign preliminary values to stab entries that did not yet *	have an absolute value (because they initially referred to *	forward references). We don't worry about .stabds, as they *	already have an estimated final value */void sortsymtab(void){	register	struct	symtab	*sp;	register	struct	symtab	**cowalk;	register	struct	allocbox	*allocwalk;			struct	symtab	*ubsp;				long	segno;				long	slotno;				long	symsin;	/*number put into symptrs*/	symptrs =  (struct symtab **)ClearCalloc(nsyms + 2, sizeof *symptrs);#ifdef DEBUG	iowprintf("symptrs in sortsymtab() allocated at %x for %d\n",symptrs,(nsyms + 2) * sizeof *symptrs);#endif	/*	 *	Allocate one word at the beginning of the symptr array	 *	so that backwards scans through the symptr array will	 *	work correctly while scanning through the zeroth segment	 */	*symptrs++ = 0;	cowalk = symptrs;	symsin = 0;	DECLITERATE(allocwalk, sp, ubsp) {		if (sp->s_ptype && (sp->s_type &STABFLAG)){			sp->s_value = sp->s_dest->s_value;			sp->s_index = sp->s_dest->s_index;		}		if (symsin >= nsyms)			yyerror("INTERNAL ERROR: overfilled symbol table indirection table");		*cowalk++ = sp;		symsin++;	}	if (symsin != nsyms)		yyerror("INTERNAL ERROR: installed %d syms, should have installed %d",			symsin, nsyms);	symptrub = &symptrs[nsyms ];	qsort((void *)symptrs, nsyms, sizeof (*symptrs), (void *) symcmp);	symdelim[0] = symptrs;	for (cowalk = symptrs, sp = *cowalk, segno = 0, slotno = 1;	     segno < NLOC + NLOC;	     segno++, slotno++){		for (; sp && sp->s_index == segno; sp = *++cowalk);		symdelim[slotno] = cowalk;	/*forms the ub delimeter*/	}}	/*end of sortsymtab*/void dumpsymtab(void){	register	long	segno;	register	struct symtab *sp, **cosp, *ub;	iowprintf("Symbol Table dump:\n");	for (segno = 0; segno < NLOC + NLOC; segno++){		iowprintf("Segment number: %d\n", segno);		SEGITERATE(segno, 0, 0, cosp, sp, ub, ++){			iowprintf("\tSeg: %d \"%s\" value: %d index: %d tag %s\n",				segno, FETCHNAME(sp),				sp->s_value, sp->s_index,				tagstring(sp->s_tag));			iowprintf("\t\ttype: %d jxbump %d jxfear: %d\n",				sp->s_type, sp->s_jxbump, sp->s_jxfear);		}		iowprintf("\n\n");	}}static	char tagbuff[4];char *tagstring(	unsigned	char	tag){	switch(tag){		case JXACTIVE:		return("active");		case JXNOTYET:		return("notyet");		case JXALIGN:		return("align");		case JXQUESTIONABLE:	return("jxquestionable");		case JXINACTIVE:	return("inactive");		case JXTUNNEL:		return("tunnel");		case OBSOLETE:		return("obsolete");		case IGNOREBOUND:	return("ignorebound");		case STABFLOATING:	return("stabfloating");		case STABFIXED:		return("stabfixed");		case LABELID:		return("labelid");		case OKTOBUMP:		return("oktobump");		case ISET:		return("iset");		case ILSYM:		return("ilsym");		default:		sprintf(tagbuff,"%d", tag);					return(tagbuff);	}}void htaballoc(void){	register	struct	hashdallop	*new;	new = (struct hashdallop *)ClearCalloc(1, sizeof (struct hashdallop));#ifdef DEBUG	iowprintf("new in htaballoc() allocated at %x for %d\n",new,sizeof (struct hashdallop));#endif	if (htab == 0)		htab = new;	else {		/* add AFTER the 1st slot */		new->h_next = htab->h_next;		htab->h_next = new;	}}#define 	HASHCLOGGED	(NHASH / 2)/* following must have no side effects */#define mytolower(c)  (isupper(c1 = (c))? c1 | 040 : c1 )/* *	Lookup a symbol stored in extern yytext. *	All strings passed in via extern yytext had better have *	a trailing null.  Strings are placed in yytext for hashing by *	syminstall() and by yylex(); * *	We take pains to avoid function calls; this functdion *	is called quite frequently, and the calls overhead *	in the vax contributes significantly to the overall *	execution speed of as. */struct symtab **lookup(	long	instflg		/* 0: don't install */){	static	 long		initialprobe;	register struct	symtab 	**hp;	register char 		*from;	register char		*to;	register	long	len;	register	long	nprobes;	static	struct	hashdallop *hdallop;	static	struct	symtab	**emptyslot;	static 	struct	hashdallop *emptyhd;	static	struct	symtab	**hp_ub;	char c1;	emptyslot = 0;	for (nprobes = 0, from = yytext;	     *from;	     nprobes <<= 2, nprobes += mytolower(*from++))		continue;	nprobes += from[-1] << 5;	nprobes %= NHASH;	if (nprobes < 0)		nprobes += NHASH;	initialprobe = nprobes;	for (hdallop = htab; hdallop != 0; hdallop = hdallop->h_next){		for (hp = &(hdallop->h_htab[initialprobe]),				nprobes = 1,				hp_ub = &(hdallop->h_htab[NHASH]);		     (*hp) && (nprobes < NHASH);				hp += nprobes,				hp -= (hp >= hp_ub) ? NHASH:0,				nprobes += 2)		{			from = yytext;			to = FETCHNAME(*hp);			while (*from && *to)				if (mytolower(*from++) != mytolower(*to++))   /*  CASE sensitivity removed!! */					goto nextprobe;			if (*to == *from)	/*assert both are == 0*/				return(hp);		nextprobe: ;		}		if (*hp == 0 && emptyslot == 0 &&		    hdallop->h_nused < HASHCLOGGED) {			emptyslot = hp;			emptyhd = hdallop;		}	}	if (emptyslot == 0) {		htaballoc();		hdallop = htab->h_next;		/* aren't we smart! */		hp = &hdallop->h_htab[initialprobe];	} else {		hdallop = emptyhd;		hp = emptyslot;	}	if (instflg) {		*hp = symalloc();		hdallop->h_nused++;		for (from = yytext, len = 0; *from++; len++)			continue;		(*hp)->s_name = (char *)savestr(yytext, len + 1, STR_BOTH);	}	return(hp);}	/*end of lookup*//* *	save a string str with len in the places indicated by place */struct strdesc *savestr(	char	*str,	long	len,	long	place){	reg	struct	strdesc	*res;		long	tlen;	/*	 *	Compute the total length of the record to live in core	 */	tlen = sizeof(struct strdesc) - sizeof(res->sd_string);	if (place & STR_CORE)		tlen += len;	/*	 *	See if there is enough space for the record,	 *	and allocate the record.	 */	if ((tlen +1) >= (STRPOOLDALLOP - strplhead->str_nalloc))		strpoolalloc();	if((unsigned long) (res = (struct strdesc *)(strplhead->str_names + strplhead->str_nalloc)) & 1)	{		res = (struct strdesc *)((char *) res + 1);		strplhead->str_nalloc++;	}	/*	 *	Save the string information that is always present	 */	res->sd_stroff = strfilepos;	res->sd_strlen = len;	res->sd_place = place;	/*	 *	Now, save the string itself.  If str is null, then	 *	the characters have already been dumped to the file	 */	if ((place & STR_CORE) && str)		movestr(res[0].sd_string, str, len);	if (place & STR_FILE){		if (str){			mfwrite(str, 1, len, strfile);		}		strfilepos += len;	}	/*	 *	Adjust the in core string pool size	 */	strplhead->str_nalloc += tlen;	return(res);}/* *	The relocation information is saved internally in an array of *	lists of relocation buffers.  The relocation buffers are *	exactly the same size as a token buffer; if we use VM for the *	temporary file we reclaim this storage, otherwise we create *	them by mallocing. */#define	RELBUFLG	TOKBUFLG#define	NRELOC		((TOKBUFLG - \			  (sizeof (long) + sizeof (struct relbufdesc *)) \			) / (sizeof (struct relocation_info)))struct	relbufdesc{	long	rel_count;	struct	relbufdesc	*rel_next;	struct	relocation_info	rel_reloc[NRELOC];};extern	struct	relbufdesc	*tok_free;#define	rel_free tok_freestatic	struct	relbufdesc	*rel_temp;struct	relocation_info r_can_1PC;struct	relocation_info	r_can_0PC;void initoutrel(void){	r_can_0PC.r_address = 0;	r_can_0PC.r_symbolnum = 0;	r_can_0PC.r_pcrel = 0;	r_can_0PC.r_length = 0;	r_can_0PC.r_extern = 0;	r_can_1PC = r_can_0PC;	r_can_1PC.r_pcrel = 1;}void outrel(	register	struct	exp	*xp,	long		reloc_how 	/* TYPB..TYPH + (possibly)RELOC_PCREL */){	struct		relocation_info	reloc;	register	long	x_type_mask;				long	pcrel;	x_type_mask = xp->e_xtype & ~XFORW;	pcrel = reloc_how & RELOC_PCREL;	reloc_how &= ~RELOC_PCREL;		if (bitoff&07)		yyerror("Padding error");	if (x_type_mask == XUNDEF)		yyerror("Undefined reference");	if ( (x_type_mask != XABS) || pcrel ) {		if (ty_NORELOC[reloc_how])			yyerror("Illegal Relocation of floating or large long number.");		reloc = pcrel ? r_can_1PC : r_can_0PC;		reloc.r_address = dotp->e_xvalue -		    ( (dotp < &usedot[NLOC] || readonlydata) ? 0 : datbase );		reloc.r_length = ty_nlg[reloc_how];		switch(x_type_mask){			case XXTRN | XUNDEF:				reloc.r_symbolnum = xp->e_xname->s_index;				reloc.r_extern = 1;				break;			default:				if (readonlydata && (x_type_mask&~XXTRN) == XDATA)					x_type_mask = XTEXT | (x_type_mask&XXTRN);				reloc.r_symbolnum = x_type_mask;				break;		}		if ( (relfil == 0) || (relfil->rel_count >= NRELOC) ){			if (rel_free){				rel_temp = rel_free;				rel_free = rel_temp->rel_next;			} else {				rel_temp = (struct relbufdesc *)					ClearCalloc(1,sizeof (struct relbufdesc));#ifdef DEBUG	iowprintf("rel_temp in outrel() allocated at %x for %d\n",rel_temp,sizeof (struct relbufdesc));#endif			}			rel_temp->rel_count = 0;			rel_temp->rel_next = relfil;			relfil = rusefile[dotp - &usedot[0]] = rel_temp;		}		relfil->rel_reloc[relfil->rel_count++] = reloc;	}	/*	 *	write the unrelocated value to the text file	 */	dotp->e_xvalue += ty_nbyte[reloc_how];/*	iowprintf("bhudda was relocating stuff here %x",xp->e_xvalue); */	if (pcrel) {		xp->e_xvalue -= dotp->e_xvalue;		}	switch(reloc_how){	case TYPO:	case TYPQ:	case TYPF:	case TYPD:	case TYPG:	case TYPH:		bignumwrite(xp->e_number, reloc_how);		break;	default:		{			/*			 *	a hack to get past different byte storage			 *	on mac.  Reverse returns pointer to swapped			 *	bytes in a static storage area			 */						bwrite(reverse( (unsigned char *)&(xp->e_xvalue) ), ty_nbyte[reloc_how], txtfil);			break;		}	}}/* *	Flush out all of the relocation information. *	Note that the individual lists of buffers are in *	reverse order, so we must reverse them */off_t closeoutrel(	BFILE	*relocfile){	long	locindex;			trsize = 0;	for (locindex = 0; locindex < NLOC; locindex++){		trsize += Closeoutrel(rusefile[locindex], relocfile);	}	drsize = 0;	for (locindex = 0; locindex < NLOC; locindex++){		drsize += Closeoutrel(rusefile[NLOC + locindex], relocfile);	}	return(trsize + drsize);}/*  *	the following is for reversing the order of bytes *	in a structure containing bitfields (struct relocation_info). *	Hence this must be the same size as the relocation info structure.  */struct silly {	long a;	union x_union {		struct x1_struct {			unsigned long num:24,				filler:4,				extrn:1,			 	length:2,				pcrel:1;		} x1;		struct x2_struct {			unsigned char bytes[4];		} x2;	} x;};	u_long Closeoutrel(	struct	relbufdesc	*relfil,	BFILE	*relocfile){	u_long	tail;	struct relocation_info temp;	long i;	register struct silly *ptrs;					/* source */	register struct silly *ptrd = ( struct silly * )&temp;	/* dest */	register struct relocation_info *ptrs2;			if (relfil == 0)		return(0L);	tail = Closeoutrel(relfil->rel_next, relocfile);	/* must reverse all the numbers for mac */	for( i=0; i<relfil->rel_count; i++ )	{		ptrs = ( struct silly * )( ptrs2 = &( relfil->rel_reloc[i] ));		ptrd->a = REVLONG( ptrs->a );		/* swap the three byte long around */		ptrd->x.x2.bytes[0] = ptrs->x.x2.bytes[2];		ptrd->x.x2.bytes[2] = ptrs->x.x2.bytes[0];		ptrd->x.x2.bytes[1] = ptrs->x.x2.bytes[1];		/* reverse ITEMS in last byte, but not bits in items */		ptrd->x.x1.filler = 0;		ptrd->x.x1.length = ptrs2->r_length;		ptrd->x.x1.extrn = ptrs2->r_extern;		ptrd->x.x1.pcrel = ptrs2->r_pcrel;		/* now send on its merry way... */		bwrite((char *)ptrd, sizeof (struct relocation_info), relocfile);	}	return(tail + relfil->rel_count * sizeof (struct relocation_info));}#define NOUTSYMS (nsyms - njxxx - nforgotten - (savelabels ? 0 : nlabels))long sizesymtab(void){	return (sizeof (struct nlist) * NOUTSYMS);}/* *	Write out n symbols to file f, beginning at p *	ignoring symbols that are obsolete, jxxx instructions, and *	possibly, labels */void symwrite(	BFILE *symfile){		long	symsout;		/*those actually written*/		long	symsdesired = NOUTSYMS;	reg	struct	symtab *sp, *ub;		char	*name;			/* temp to save the name */		long	totalstr;		long revtotalstr;		/* reversed for writing on the mac */	/*	 *	We use sp->s_index to hold the length of the	 *	name; it isn't used for anything else	 */	register	struct	allocbox	*allocwalk;		struct nlist temp;	symsout = 0;	totalstr = sizeof(totalstr);	DECLITERATE(allocwalk, sp, ub) {		if (sp->s_tag >= IGNOREBOUND) 			continue;		if (ISLABEL(sp))			continue;		symsout++;		name = sp->s_name;		/* save pointer */		/*		 *	the length of the symbol table string		 *	always includes the trailing null;		 *	blast the pointer to its a.out value.		 */		if (sp->s_name && (sp->s_index = STRLEN(sp))){			sp->s_nmx = totalstr;			totalstr += sp->s_index;		} else {			sp->s_nmx = 0;		}		if (sp->s_ptype != 0)			sp->s_type = sp->s_ptype;		else			sp->s_type = (sp->s_type & (~XFORW));		if (readonlydata && (sp->s_type&~N_EXT) == N_DATA)			sp->s_type = N_TEXT | (sp->s_type & N_EXT);				temp.n_un.n_strx = REVLONG( sp->s_nm.n_un.n_strx );		temp.n_type = sp->s_nm.n_type;		temp.n_other = sp->s_nm.n_other;		temp.n_desc = REVSHORT( sp->s_nm.n_desc );		temp.n_value = REVLONG( sp->s_nm.n_value );		bwrite((char *)&temp, sizeof (struct nlist), symfile);		sp->s_name = name;		/* restore pointer *//*		iowprintf("name = %s, Type =%x, value %x\n",FETCHNAME(sp),temp.n_type,temp.n_value); */	}	if (symsout != symsdesired)		yyerror("INTERNAL ERROR: Wrote %d symbols, wanted to write %d symbols\n",			symsout, symsdesired);	/*	 *	Construct the string pool from the symbols that were written,	 *	possibly fetching from the string file if the string	 *	is not core resident.	 */	 revtotalstr = REVLONG( totalstr );	bwrite((char *)&revtotalstr, sizeof(revtotalstr), symfile);	symsout = 0;	DECLITERATE(allocwalk, sp, ub) {		if (sp->s_tag >= IGNOREBOUND) 			continue;		if (ISLABEL(sp))			continue;		symsout++;		if (STRLEN(sp) > 0){		 if (STRPLACE(sp) & STR_CORE){			bwrite(FETCHNAME(sp), STRLEN(sp), symfile);			/* iowprintf("Outputing string %s\n",FETCHNAME(sp)); */		 } else if (STRPLACE(sp) & STR_FILE){			char	rbuf[2048];			long	left, nread;			mfseek(strfile, STROFF(sp), 0);			for (left = STRLEN(sp); left > 0; left -= nread){				nread = mfread(rbuf, sizeof(char),					min(sizeof(rbuf), left), strfile);				if (nread == 0)					break;				bwrite(rbuf, nread, symfile);			/* iowprintf("Outputing string %s\n",rbuf); */			}		 }		}	}	if (symsout != symsdesired)		yyerror("INTERNAL ERROR: Wrote %d strings, wanted %d\n",			symsout, symsdesired);}