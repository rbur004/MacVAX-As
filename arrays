File "as.h"; Line 83 # #define	AINDX	16	/* [%r] */File "as.h"; Line 106 # extern	int	reflen[];	/* {LEN*+PCREL} ==> number of bytes */File "as.h"; Line 107 # extern	int	lgreflen[];	/* {LEN*+PCREL} ==> lg number of bytes */File "as.h"; Line 108 # extern	int	len124[];	/* {1,2,4,8,16} ==> {LEN1, LEN2, LEN4, LEN8} */File "as.h"; Line 109 # extern	char	mod124[];	/* {1,2,4,8,16} ==> {bits to construct operands */File "as.h"; Line 110 # extern	int	type_124[];	/* {1,2,4,8,16} ==> {TYPB,TYPW,TYPL,TYPQ,TYPO} */File "as.h"; Line 111 # extern	int	ty_NORELOC[];	/* {TYPB..TYPH} ==> {1 if relocation not OK */File "as.h"; Line 112 # extern	int	ty_float[];	/* {TYPB..TYPH} ==> {1 if floating number */File "as.h"; Line 113 # extern	int	ty_LEN[];	/* {TYPB..TYPH} ==> {LEN1..LEN16} */File "as.h"; Line 114 # extern	int	ty_nbyte[];	/* {TYPB..TYPH} ==> {1,2,4,8,16} */File "as.h"; Line 115 # extern	int	ty_nlg[];	/* {TYPB..TYPH} ==> lg{1,2,4,8,16} */File "as.h"; Line 116 # extern	char	*ty_string[];	/* {TYPB..TYPH} ==> printable */File "as.h"; Line 225 # 	char	s_pad[2];		/* round to 20 bytes */File "as.h"; Line 278 # #define	ITABCHECK(o)	((itab[o.Op_eopcode] != (Iptr*)BADPOINT) && (itab[o.Op_eopcode][o.Op_popcode] != (Iptr)BADPOINT))File "as.h"; Line 282 # #define	ITABFETCH(o)	itab[o.Op_eopcode][o.Op_popcode]File "as.h"; Line 288 # 	char	I_args[6];File "as.h"; Line 291 # 	char	I_pad[2];		/* round to 20 bytes */File "as.h"; Line 300 # #define	fetcharg(ptr, n) ((struct Instab *)ptr)->I_args[n]File "as.h"; Line 352 # 	char	sd_string[1];	/* the string itself, flexible length */File "as.h"; Line 366 # 	extern	struct	arg	arglist[NARG];	/*building operands in instructions*/File "as.h"; Line 367 # 	extern	struct	exp	explist[NEXP];	/*building up a list of expressions*/File "as.h"; Line 379 # 	 *	lgensym[i] is the current funny number to put afterFile "as.h"; Line 380 # 	 *	references to if, lgensym[i]-1 is for ib.File "as.h"; Line 381 # 	 *	genref[i] is set when the label is referenced beforeFile "as.h"; Line 386 # 	extern	int	lgensym[10];File "as.h"; Line 387 # 	extern	char	genref[10];File "as.h"; Line 409 # 	extern	char	yytext[NCPName+2];	/* text buffer for lexical */File "as.h"; Line 418 # 	extern	char	tokfilename[TNAMESIZE];	/* token file name */File "as.h"; Line 419 # 	extern	char	strfilename[TNAMESIZE];	/* string file name */File "as.h"; Line 442 # 	extern	struct	instab	**itab[NINST];	/*maps opcodes to instructions*/File "as.h"; Line 443 # 	extern  readonly struct Instab instab[];File "as.h"; Line 498 # 	extern	struct	exp	usedot[NLOC + NLOC];File "as.h"; Line 499 # 	extern		BFILE	*usefile[NLOC + NLOC];File "as.h"; Line 509 # 	struct	relbufdesc	*rusefile[NLOC + NLOC];File "ascode.c"; Line 8 # static char sccsid[] = "@(#)ascode.c	5.1 (Berkeley) 4/24/85";File "ascode.c"; Line 202 # 			dotp->e_xvalue += ty_nbyte[argtype];File "ascode.c"; Line 282 # 			ap->a_areg1 |= (0xAF + mod124[ap->a_dispsize]);File "ascode.c"; Line 283 # 			reloc_how = type_124[ap->a_dispsize] + RELOC_PCREL;File "ascode.c"; Line 289 # 				ap->a_areg1 += mod124[ap->a_dispsize];File "ascode.c"; Line 290 # 				reloc_how = type_124[ap->a_dispsize];File "ascode.c"; Line 402 # 		fits = ty_nbyte[argtype] >= ty_nbyte[numtype];File "ascode.c"; Line 406 # 		ty_string[numtype],File "ascode.c"; Line 407 # 		ty_string[argtype]);File "asexpr.c"; Line 8 # static char sccsid[] = "@(#)asexpr.c	5.2 (Berkeley) 6/19/85";File "asexpr.c"; Line 24 # readonly char pltab[6][6] = {File "asexpr.c"; Line 38 # readonly char mintab[6][6] = {File "asexpr.c"; Line 52 # readonly char othtab[6][6] = {File "asexpr.c"; Line 106 # 		back_type = pltab[e1_type][e2_type];File "asexpr.c"; Line 110 # 		back_type = mintab[e1_type][e2_type];File "asexpr.c"; Line 150 # 		back_type = othtab[e1_type][e2_type];File "asexpr.c"; Line 169 # #define clobber(val, set) tokensets[(val)] |= (set)File "asexpr.c"; Line 328 # 			if (lgensym[yylval] == 1)File "asexpr.c"; Line 332 # 			genref[yylval] = 1;File "asexpr.c"; Line 334 # 		(void)sprintf(yytext, "L%d\001%d", yylval, lgensym[yylval] + off);File "asexpr.c"; Line 371 # static char pdirect[]	= "directive";File "asexpr.c"; Line 372 # static char pinstr[]	= "instruction";File "asexpr.c"; Line 373 # static char phunk[]	= "lexeme";File "asexpr.c"; Line 374 # static char psmall[]	= "small symbol";File "asexpr.c"; Line 375 # static char pcntrl[]	= "control token";File "asexpr.c"; Line 388 # struct Tok_Desc *tok_name[LASTTOKEN - FIRSTTOKEN + 1];File "asexpr.c"; Line 390 # struct Tok_Desc tok_desc[] = {File "asexpr.c"; Line 448 # 	SIZESPEC,	SMALL,	"size specifier, [BWLbwl]",File "asexpr.c"; Line 449 # 	SIZEQUOTE,	SMALL,	"sizequote, [^']",File "asexpr.c"; Line 456 # 	ALPH,		SMALL,	"alphabetic character, [A-Za-z_]",File "asexpr.c"; Line 457 # 	DIG,		SMALL,	"digit character, [A-Fa-f0-9]",File "asexpr.c"; Line 492 # 	static	char	buf[64];File "asexpr.c"; Line 499 # 			tok_name[i] = &NA;File "asexpr.c"; Line 501 # 			tok_name[tok_desc[i].tok_which] = &tok_desc[i];File "asexpr.c"; Line 506 # 		sprintf(buf, "%s %s", tok_name[token]->tok_kind,File "asexpr.c"; Line 507 # 			tok_name[token]->tok_name);File "asexpr.h"; Line 52 # extern	char	tokensets[(LASTTOKEN) - (FIRSTTOKEN) + 1];File "asexpr.h"; Line 62 # #define	INTOKSET(val, set)	(tokensets[(val)] & (set) )File "asio.c"; Line 8 # static char sccsid[] = "@(#)asio.c	5.1 (Berkeley) 4/30/85";File "asjxxx.c"; Line 8 # static char sccsid[] = "@(#)asjxxx.c	5.2 (Berkeley) 6/19/85";File "asjxxx.c"; Line 523 # 	usedot[segno].e_xvalue += cum_bump;File "asmain.c"; Line 10 # char copyright[] =File "asmain.c"; Line 16 # static char sccsid[] = "@(#)asmain.c	5.2 (Berkeley) 10/21/85";File "asmain.c"; Line 84 # struct	exp	usedot[NLOC+NLOC];	/* info about all segments */File "asmain.c"; Line 92 # char	tokfilename[TNAMESIZE];File "asmain.c"; Line 98 # char	strfilename[TNAMESIZE];File "asmain.c"; Line 117 # BFILE	*usefile[NLOC+NLOC];		/* text/data files */File "asmain.c"; Line 165 # struct	relbufdesc	*rusefile[NLOC+NLOC];	File "asmain.c"; Line 185 # 	tokfilename[0] = 0;File "asmain.c"; Line 186 # 	strfilename[0] = 0;File "asmain.c"; Line 238 # 	char	*argv[];File "asmain.c"; Line 247 # 	innames = (char **)ClearCalloc(argc+1, sizeof (innames[0]));File "asmain.c"; Line 250 # 		if (argv[1][0] != '-')File "asmain.c"; Line 251 # 			innames[ninfiles++] = argv[1];File "asmain.c"; Line 253 # 			cp = argv[1] + 1;File "asmain.c"; Line 269 # 						yyerror("-d[124] only");File "asmain.c"; Line 287 # 					outfile = argv[2];File "asmain.c"; Line 298 # 					tmpdirprefix = argv[2];File "asmain.c"; Line 330 # 	/* innames[ninfiles] = 0; */File "asmain.c"; Line 356 # 		usedot[locindex].e_xtype = XTEXT;File "asmain.c"; Line 357 # 		usedot[NLOC + locindex].e_xtype = XDATA;File "asmain.c"; Line 358 # 		usedot[locindex].e_xvalue = 0;File "asmain.c"; Line 359 # 		usedot[NLOC + locindex].e_xvalue = 0;File "asmain.c"; Line 368 # 		lgensym[i] = 1;File "asmain.c"; Line 369 # 		genref[i] = 0;File "asmain.c"; Line 413 # 	dotp = &usedot[0];File "asmain.c"; Line 424 # 			new_dot_s(innames[i]);File "asmain.c"; Line 425 # 			if (freopen(innames[i], "r", stdin) == NULL) {File "asmain.c"; Line 427 # 					innames[i]);File "asmain.c"; Line 443 # 		if (genref[i])File "asmain.c"; Line 445 # 		lgensym[i] = 1;File "asmain.c"; Line 446 # 		genref[i] = 0;File "asmain.c"; Line 500 # 	 *	the exec header always goes in usefile[0]File "asmain.c"; Line 504 # 		v = round(usedot[locindex].e_xvalue, FW);File "asmain.c"; Line 505 # 		usedot[locindex].e_xvalue = tsize;File "asmain.c"; Line 507 # 			usefile[locindex] = (BFILE *)Calloc(1, sizeof(BFILE));File "asmain.c"; Line 508 # 			bopen(usefile[locindex], a_out_off);File "asmain.c"; Line 512 # 			usefile[locindex] = (BFILE *)-1;File "asmain.c"; Line 522 # 		v = round(usedot[NLOC+locindex].e_xvalue, FW);File "asmain.c"; Line 523 # 		usedot[NLOC+locindex].e_xvalue = datbase + dsize;File "asmain.c"; Line 525 # 			usefile[NLOC + locindex] = (BFILE *)Calloc(1,sizeof(BFILE));File "asmain.c"; Line 526 # 			bopen(usefile[NLOC + locindex], a_out_off);File "asmain.c"; Line 528 # 			usefile[NLOC + locindex] = (BFILE *)-1;File "asmain.c"; Line 544 # 		rusefile[locindex] = (struct relbufdesc *)0;File "asmain.c"; Line 567 # 	bwrite((char *)&hdr, sizeof(hdr), usefile[0]);File "asmain.c"; Line 592 # 	dotp = &usedot[0];File "asmain.c"; Line 593 # 	txtfil = usefile[0];	/* already opened (always!) */File "asmain.c"; Line 611 # 		if (usefile[locindex]) {File "asmain.c"; Line 612 # 			txtfil = usefile[locindex];File "asmain.c"; Line 613 # 			dotp = &usedot[locindex];File "asmain.c"; Line 614 # 			while (usedot[locindex].e_xvalue & FW)File "asmain.c"; Line 672 # 	if (useVM == 0 || tokfilename[0])File "asmain.c"; Line 674 # 	if (strfilename[0])File "asnumber.h"; Line 10 # 	u_char	Ib_uchar[1];File "asnumber.h"; Line 14 # 	u_char	Iw_uchar[2];File "asnumber.h"; Line 15 # 	u_short	Iw_ushort[1];File "asnumber.h"; Line 19 # 	u_char	Il_uchar[4];File "asnumber.h"; Line 20 # 	u_short	Il_ushort[2];File "asnumber.h"; Line 21 # 	u_int	Il_ulong[1];File "asnumber.h"; Line 26 # 	u_char	Iq_uchar[8];File "asnumber.h"; Line 27 # 	u_short	Iq_ushort[4];File "asnumber.h"; Line 28 # 	u_int	Iq_ulong[2];File "asnumber.h"; Line 32 # 	u_char	Io_uchar[16];File "asnumber.h"; Line 33 # 	u_short	Io_ushort[8];File "asnumber.h"; Line 34 # 	u_int	Io_ulong[4];File "asnumber.h"; Line 35 # 	union	Iq_int	Io_quad[2];File "asnumber.h"; Line 39 # 	u_char	Ff_uchar[4];File "asnumber.h"; Line 40 # 	u_short	Ff_ushort[2];File "asnumber.h"; Line 41 # 	u_int	Ff_ulong[1];File "asnumber.h"; Line 46 # 	u_char	Fd_uchar[8];File "asnumber.h"; Line 47 # 	u_short	Fd_ushort[4];File "asnumber.h"; Line 48 # 	u_int	Fd_ulong[2];File "asnumber.h"; Line 53 # 	u_char	Fg_uchar[8];File "asnumber.h"; Line 54 # 	u_short	Fg_ushort[4];File "asnumber.h"; Line 55 # 	u_int	Fg_ulong[2];File "asnumber.h"; Line 59 # 	u_char	Fh_uchar[16];File "asnumber.h"; Line 60 # 	u_short	Fh_ushort[8];File "asnumber.h"; Line 61 # 	u_int	Fh_ulong[4];File "asnumber.h"; Line 166 #  *	byte #i in the packed number goes to byte #b_upmmap[i] in the unpackedFile "asnumber.h"; Line 170 # 	char	b_upmmap[16];	/* byte x of float goes to up_mmap[x] in mant */File "asnumber.h"; Line 171 # 	char	b_pmmap[16];	/* inverse of upmmap */File "asnumber.h"; Line 172 # 	char	b_upemap[2];	/* byte x of float goes to up_emap[x] in exp */File "asnumber.h"; Line 173 # 	char	b_pemap[2];	/* inverse of upemap */File "asnumber.h"; Line 180 # extern struct ty_bigdesc ty_bigdesc[];File "asparse.c"; Line 8 # static char sccsid[] = "@(#)asparse.c	5.2 (Berkeley) 6/19/85";File "asparse.c"; Line 17 # int	lgensym[10];File "asparse.c"; Line 18 # char	genref[10];File "asparse.c"; Line 35 # char	yytext[NCPName+2];	/*the lexical image*/File "asparse.c"; Line 43 # struct	exp	explist[NEXP];	/*max of 20 expressions in one opcode*/File "asparse.c"; Line 44 # struct	arg	arglist[NARG];	/*building up operands in instructions*/File "asparse.c"; Line 48 # char	tokensets[(LASTTOKEN) - (FIRSTTOKEN) + 1];File "asparse.c"; Line 50 # static	char	UDotsname[64];	/*name of the assembly source*/File "asparse.c"; Line 79 # 		int	sawindex;	/*saw [rn]*/File "asparse.c"; Line 116 # 			(void)sprintf(yytext, "L%d\001%d", i, lgensym[i]);File "asparse.c"; Line 117 # 			lgensym[i]++;File "asparse.c"; Line 118 # 			genref[i] = 0;File "asparse.c"; Line 164 # 				if (FETCHNAME(np)[0] == 'L'){File "asparse.c"; Line 192 # 	tokptr[1] = VOID;File "asparse.c"; Line 193 # 	tokptr[2] = PARSEEOF;File "asparse.c"; Line 200 # 	dotsname = &UDotsname[0];File "asparse.c"; Line 260 #    case IDATA: 	/*.data [ <expr> ] */File "asparse.c"; Line 261 #    case ITEXT: 	/*.code [ <expr> ] */File "asparse.c"; Line 282 # 	dotp = &usedot[seg_number];File "asparse.c"; Line 284 # 		txtfil = usefile[seg_number];File "asparse.c"; Line 285 # 		relfil = rusefile[seg_number];File "asparse.c"; Line 292 # 	 *	.byte	[<exprlist>]File "asparse.c"; Line 346 # 				dotp->e_xvalue += ty_nbyte[reloc_how];File "asparse.c"; Line 389 # 		static char spacebuf[128];File "asparse.c"; Line 428 #    case IASCII:		/* .ascii [ <stringlist> ] */File "asparse.c"; Line 429 #    case IASCIZ: 	/* .asciz [ <stringlist> ] */File "asparse.c"; Line 817 # 	  index:			/*look for [reg] */File "asparse.c"; Line 902 # 				ERROR(ty_float[toconv]File "asparse.c"; Line 906 # 			dotp->e_xvalue += ty_nbyte[toconv];File "asparse.c"; Line 950 #  *	%dd[+-]*, where dd is a decimal number in the range 00 to 15 (optionalFile "aspseudo.c"; Line 8 # static char sccsid[] = "@(#)aspseudo.c	5.1 (Berkeley) 4/30/85";File "aspseudo.c"; Line 25 # readonly struct Instab instab[] = {File "asscan.h"; Line 31 # 	char		toks[AVAILTOKS];File "asscan.h"; Line 32 # 	char		bufovf[MAXVAX + SAFETY];File "asscan1.c"; Line 8 # static char sccsid[] = "@(#)asscan1.c	5.1 (Berkeley) 4/30/85";File "asscan1.c"; Line 17 # 			bufstart = &tokbuf[0];File "asscan1.c"; Line 18 # 			buftail = &tokbuf[1];File "asscan1.c"; Line 22 # 		tokbuf[0].tok_count = -1;File "asscan1.c"; Line 23 # 		tokbuf[1].tok_count = -1;File "asscan1.c"; Line 28 # 	emptybuf = &tokbuf[bufno];File "asscan1.c"; Line 37 # 			emptybuf->toks[emptybuf->tok_count++] = PARSEEOF;File "asscan1.c"; Line 43 # 			if (tokbuf[bufno ^ 1].tok_count >= 0){File "asscan1.c"; Line 44 # 				if (writeTEST((char *)&tokbuf[bufno ^ 1], sizeof *emptybuf, 1, tokfile)){File "asscan1.c"; Line 55 # 			tokbuf[bufno].toks[tokbuf[bufno].tok_count++] = PARSEEOF;File "asscan1.c"; Line 56 # 			if (writeTEST((char *)&tokbuf[bufno], sizeof *emptybuf, 1, tokfile))File "asscan1.c"; Line 83 # 				if (xp >= &explist[NEXP])File "asscan1.c"; Line 97 # 				if (xp >= &explist[NEXP])File "asscan1.c"; Line 208 # 		(bytetoktype *)bufptr = &(emptybuf->toks[0]);File "asscan1.c"; Line 213 # 		emptybuf = &tokbuf[bufno];File "asscan1.c"; Line 214 # 		((bytetoktype *)bufptr) = &(emptybuf->toks[0]);File "asscan1.c"; Line 268 # 	middlebuf = useVM ? emptybuf : &tokbuf[1];File "asscan1.c"; Line 286 # 		(bytetoktype *)from = (bytetoktype *)&(emptybuf->toks[0]);File "asscan2.c"; Line 8 # static char sccsid[] = "@(#)asscan2.c	5.1 (Berkeley) 4/30/85";File "asscan2.c"; Line 15 # char	inbufunget[8];File "asscan2.c"; Line 16 # char	inbuffer[ASINBUFSIZ];File "asscan2.c"; Line 48 # 		inbuffer[0] = EOFCHAR;File "asscan2.c"; Line 76 # 	(bytetoktype *)bufptr = (bytetoktype *) & (bufferbox->toks[0]);	File "asscan2.c"; Line 77 # 	(bytetoktype *)bufub = &(bufferbox->toks[AVAILTOKS]);File "asscan2.c"; Line 95 #         switch(ryylval = (type+1)[ch = getchar()]) {File "asscan2.c"; Line 138 # 			 *	style comment '^#[ \t]*[0-9]*[ \t]*".*"File "asscan2.c"; Line 239 # 			if (rcp < &yytext[NCPName])File "asscan2.c"; Line 445 # 	bufferbox->tok_count = (bytetoktype *)bufptr - &(bufferbox->toks[0]);File "asscan3.c"; Line 8 # static char sccsid[] = "@(#)asscan3.c	5.1 (Berkeley) 4/30/85";File "asscan3.c"; Line 13 # readonly short type[] = {File "asscan3.c"; Line 147 # readonly short charsets[] = {File "asscan4.c"; Line 8 # static char sccsid[] = "@(#)asscan4.c	5.1 (Berkeley) 4/30/85";File "asscan4.c"; Line 17 # static char	numbuf[NUMSIZE];File "asscan4.c"; Line 155 # 		if (maxstrlg == 11 && numbuf[0] > 3)File "asscan4.c"; Line 178 # 	if (cp == &numbuf[NUMSIZE]){ \File "asscanl.h"; Line 40 # #define	INCHARSET(val, kind) (charsets[val] & (kind) )File "asscanl.h"; Line 54 # 		inbufptr[-1]))File "asscanl.h"; Line 82 # struct 	tokbufdesc tokbuf[2];	/*our initial increment of buffers*/File "asscanl.h"; Line 130 # readonly short charsets[];File "asscanl.h"; Line 131 # readonly short type[];File "assizetab.c"; Line 8 # static char sccsid[] = "@(#)assizetab.c	5.1 (Berkeley) 4/30/85";File "assizetab.c"; Line 19 # int	reflen[] = { 	/* {LEN*+PCREL} ==> number of bytes */File "assizetab.c"; Line 27 # int	lgreflen[] = { 	/* {LEN*+PCREL} ==> number of bytes */File "assizetab.c"; Line 43 # int	len124[] = {File "assizetab.c"; Line 57 # char	mod124[] = {File "assizetab.c"; Line 71 # int	type_124[] = {File "assizetab.c"; Line 84 #  *	Convert TYP[BWLQOFDGH] into {1 if relocation not OK}File "assizetab.c"; Line 86 # int	ty_NORELOC[] = {File "assizetab.c"; Line 100 #  *	Convert TYP[BWLQOFDGH] into {1 if a floating point number}File "assizetab.c"; Line 102 # int	ty_float[] = {File "assizetab.c"; Line 117 #  *	Convert TYP[BWLQOFDGH] into {LEN1 ... LEN16}File "assizetab.c"; Line 119 # int	ty_LEN[] = {File "assizetab.c"; Line 133 #  *	Convert TYP[BWLQOFDGH] into {1 ... 16}File "assizetab.c"; Line 135 # int	ty_nbyte[] = {File "assizetab.c"; Line 149 #  *	Convert TYP[BWLQOFDGH] into lg{1 ... 16}File "assizetab.c"; Line 151 # int	ty_nlg[] = {File "assizetab.c"; Line 164 #  *	Convert TYP[BWLQOFDGH] into stringsFile "assizetab.c"; Line 166 # char	*ty_string[] = {File "assyms.c"; Line 8 # static char sccsid[] = "@(#)assyms.c	5.1 (Berkeley) 4/30/85";File "assyms.c"; Line 29 # struct	symtab		**symdelim[NLOC + NLOC +1];File "assyms.c"; Line 36 # Iptr	*itab[NINST];	/*maps opcodes to instructions*/File "assyms.c"; Line 75 # 		itab[i] = (Iptr*)BADPOINT;File "assyms.c"; Line 77 # 	for (ip = (Iptr)instab; FETCHNAME(ip)[0]; ip++) {File "assyms.c"; Line 88 # 			if (itab[ip->i_eopcode] == (Iptr*)BADPOINT){File "assyms.c"; Line 89 # 				itab[ip->i_eopcode] =File "assyms.c"; Line 92 # 					itab[ip->i_eopcode][i] =File "assyms.c"; Line 95 # 			itab[ip->i_eopcode][ip->i_popcode] = ip;File "assyms.c"; Line 106 # 	 && (FETCHNAME(sp)[0] == 'L'))File "assyms.c"; Line 134 # 			sp->s_value += usedot[sp->s_index].e_xvalue;File "assyms.c"; Line 136 # 			sp->s_value += usedot[sp->s_index].e_xvalue;File "assyms.c"; Line 219 # 		nextsym = &newbox->symslots[0];File "assyms.c"; Line 315 # 	symptrub = &symptrs[nsyms ];File "assyms.c"; Line 317 # 	symdelim[0] = symptrs;File "assyms.c"; Line 322 # 		symdelim[slotno] = cowalk;	/*forms the ub delimeter*/File "assyms.c"; Line 350 # static	char tagbuff[4];File "assyms.c"; Line 420 # 	nprobes += from[-1] << 5;File "assyms.c"; Line 427 # 		for (hp = &(hdallop->h_htab[initialprobe]),File "assyms.c"; Line 429 # 				hp_ub = &(hdallop->h_htab[NHASH]);File "assyms.c"; Line 453 # 		hp = &hdallop->h_htab[initialprobe];File "assyms.c"; Line 501 # 		movestr(res[0].sd_string, str, len);File "assyms.c"; Line 529 # 	struct	relocation_info	rel_reloc[NRELOC];File "assyms.c"; Line 567 # 		if (ty_NORELOC[reloc_how])File "assyms.c"; Line 571 # 		    ( (dotp < &usedot[NLOC] || readonlydata) ? 0 : datbase );File "assyms.c"; Line 572 # 		reloc.r_length = ty_nlg[reloc_how];File "assyms.c"; Line 594 # 			relfil = rusefile[dotp - &usedot[0]] = rel_temp;File "assyms.c"; Line 596 # 		relfil->rel_reloc[relfil->rel_count++] = reloc;File "assyms.c"; Line 601 # 	dotp->e_xvalue += ty_nbyte[reloc_how];File "assyms.c"; Line 616 # 		bwrite((char *)&(xp->e_xvalue), ty_nbyte[reloc_how], txtfil);File "assyms.c"; Line 633 # 		trsize += Closeoutrel(rusefile[locindex], relocfile);File "assyms.c"; Line 637 # 		drsize += Closeoutrel(rusefile[NLOC + locindex], relocfile);File "assyms.c"; Line 650 # 	bwrite((char *)&relfil->rel_reloc[0],File "assyms.c"; Line 729 # 			char	rbuf[2048];File "assyms.h"; Line 17 # extern	struct	symtab	**symdelim[NLOC + NLOC + 1];File "assyms.h"; Line 26 # 	for(copointer = start == 0? symdelim[segno]:start,\File "assyms.h"; Line 27 # 	    ubpointer = end == 0 ? *symdelim[segno+1] : *(symdelim[segno]-1),\File "assyms.h"; Line 45 # 	struct		symtab		symslots[SYMDALLOP];File "assyms.h"; Line 54 # 	char		str_names[STRPOOLDALLOP];File "assyms.h"; Line 75 # 		for (walkpointer = &allocwalk->symslots[0],\File "assyms.h"; Line 76 # 		        ubpointer = &allocwalk->symslots[SYMDALLOP], \File "assyms.h"; Line 97 # 	struct	symtab		*h_htab[NHASH];File "bignum1.c"; Line 8 # static char sccsid[] = "@(#)bignum1.c	5.1 (Berkeley) 4/30/85";File "bignum1.c"; Line 133 # 		if (bcp[i] == val)File "bignum1.c"; Line 137 # 		static u_char tagtab[4][16] = {File "bignum1.c"; Line 159 # 		n_n.num_tag = tagtab[HOC][i];File "bignum1.c"; Line 172 # 	if (src[HOC] & SIGNBIT)File "bignum1.c"; Line 174 # 	if (src[HOC] == SIGNBIT){File "bignum1.c"; Line 176 # 			if (src[i] != 0)File "bignum1.c"; Line 269 # 	work.num_uchar[0] = val;File "bignum1.c"; Line 335 # 	if (!ty_float[argtype])File "bignum1.c"; Line 346 # 		if (CH_FIELD(unpacked)[i])File "bignum1.c"; Line 349 # 	if ((CH_FIELD(unpacked)[HOC]) & ONES(CH_BITS - MANTPREC))File "bignum1.c"; Line 352 # 	mask = (CH_FIELD(unpacked)[HOC]) >> (CH_BITS - MANTPREC);File "bignum1.c"; Line 377 # 	int	toconv;		/* one of TYP[QO FDGH] */File "bignum1.c"; Line 384 # 	bp = &number.num_uint[0];File "bignum1.c"; Line 397 # 	bwrite((char *)bp, ty_nbyte[toconv], txtfil);File "bignum2.c"; Line 8 # static char sccsid[] = "@(#)bignum2.c	5.1 (Berkeley) 4/30/85";File "bignum2.c"; Line 23 # 	if (ty_nbyte[number.num_tag] > ty_nbyte[convto] && (passno == 2)){File "bignum2.c"; Line 25 # 			ty_string[number.num_tag],File "bignum2.c"; Line 26 # 			ty_string[convto]);File "bignum2.c"; Line 28 # 	for (i = ty_nbyte[convto]; i < ty_nbyte[TYPO]; i++)File "bignum2.c"; Line 29 # 		number.num_uchar[i] = 0;File "bignum2.c"; Line 47 # 	bp = &number.num_uint[0];File "bignum2.c"; Line 92 # 			ty_string[number.num_tag],File "bignum2.c"; Line 93 # 			ty_string[convto],File "bignum2.c"; Line 149 # 	p = &ty_bigdesc[Packed.num_tag];File "bignum2.c"; Line 186 # 		if (mantissa[HOC] & SIGNBIT){File "bignum2.c"; Line 202 # 				if (mantissa[HOC] & mask)File "bignum2.c"; Line 209 # 		assert(mantissa[HOC] & SIGNBIT, "integer <<ing");File "bignum2.c"; Line 225 # 		exponent = Enumber.num_ushort[0] & ONES(15);File "bignum2.c"; Line 239 # 		sign = (Enumber.num_ushort[0] & ~ONES(15)) ? -1 : 0;File "bignum2.c"; Line 281 # 	p = &ty_bigdesc[toconv];File "bignum2.c"; Line 299 # 		temp[HOC] |= SIGNBIT;File "bignum2.c"; Line 306 # 			temp[HOC] &= ~SIGNBIT;File "bignum2.c"; Line 403 # 		Enumber.num_ushort[0] = exponent;File "bignum2.c"; Line 428 # 		switch(themap[i]){File "bignum2.c"; Line 432 # 			p1[themap[i]] |= p2[i];File "bignum2.c"; Line 461 # 	number = CH_FIELD(numberp[0]);File "bignum2.c"; Line 482 # 	bytep[15] |= hofractionbit;File "bignum2.c"; Line 487 # 	ulp.num_uchar[byteindex] |= (0x80 >> UPSHIFT);File "bignum2.c"; Line 489 # 	ulp.num_uchar[byteindex] &= ~(0x80 >> UPSHIFT);File "bignum2.c"; Line 497 # 	if (bytep[15] & ovffractionbit){File "bignum2.c"; Line 507 # 	bytep[15] &= ONES(8 - p->b_mlshift);File "bignum2.c"; Line 515 # 		ty_string[number.num_tag],File "bignum2.c"; Line 518 # 		number.num_uint[3],File "bignum2.c"; Line 519 # 		number.num_uint[2],File "bignum2.c"; Line 520 # 		number.num_uint[1],File "bignum2.c"; Line 521 # 		number.num_uint[0]);File "bignum2.c"; Line 549 # 	} ovftab[] = {File "bignum2.c"; Line 562 # 	for(i = 0; ovftab[i].which; i++){File "bignum2.c"; Line 563 # 		if (ovf & ovftab[i].which)File "bignum2.c"; Line 564 # 			printf("Overflow(%s) ", ovftab[i].print);File "floattab.c"; Line 8 # static char sccsid[] = "@(#)floattab.c	5.1 (Berkeley) 4/30/85";File "floattab.c"; Line 15 # struct ty_bigdesc ty_bigdesc[] = {File "floattab.c"; Line 124 # 		extern	int	ty_float[];File "floattab.c"; Line 127 # 		p = &ty_bigdesc[i];File "floattab.c"; Line 129 # 			if (((char)p->b_upmmap[j]) != NOTAKE){File "floattab.c"; Line 130 # 				k = p->b_pmmap[p->b_upmmap[j]];File "floattab.c"; Line 132 # 					printf("%s:p[up[%d]] == %d\n",File "floattab.c"; Line 133 # 						ty_string[i],j,k);File "floattab.c"; Line 136 # 			if (((char)p->b_pmmap[j]) != NOTAKE){File "floattab.c"; Line 137 # 				k = p->b_upmmap[p->b_pmmap[j]];File "floattab.c"; Line 139 # 					printf("%s:up[p[%d]] == %d\n",File "floattab.c"; Line 140 # 						ty_string[i],j,k);File "floattab.c"; Line 143 # 		if (!ty_float[i])File "instrs.h"; Line 66 #  *	For real memory addresses, or register addresses [sic]File "instrs.h"; Line 132 # 	u_char	argtype[6];File "instrs.h"; Line 133 # } insttab[];File "natof.c"; Line 8 # static char sccsid[] = "@(#)natof.c	5.1 (Berkeley) 4/30/85";File "natof.c"; Line 69 # 		assert(((acc[HOC] & SIGNBIT) == 0), "Negative HOC");File "natof.c"; Line 70 # 		if (acc[HOC] < MAXINT_10){File "natof.c"; Line 170 # 		assert(((acc[HOC] & SIGNBIT) == 0), "Negative HOC");File "natof.c"; Line 177 # 			while((acc[HOC] & quotient) == 0){File "natof.c"; Line 203 # 			 *	Divide (remainder:16).(acc[i]:16)File "natof.c"; Line 205 # 			 *	into acc[i]:16, and save the remainderFile "natof.c"; Line 208 # 			dividend = (remainder << 16) | (sptr[i] & ONES(16));File "natof.c"; Line 212 # 			sptr[i] = quotient;File "natof.c"; Line 222 # 		dividend = (remainder << 16) | (sptr[0] & ONES(16));File "natof.c"; Line 226 # 		sptr[0] = quotient + quotient;File "natof.c"; Line 245 # 		while ( ((unsigned)acc[HOC]) > MAXINT_5){File "stat.h"; Line 60 #         long    st_spare4[2];