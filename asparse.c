#pragma segment ASPARSE/* will be loaded with pass 1.  Want it to stay always. */#include <String.h>#include <StdIO.h>#include "mstdio.h"#include "as.h"#include "asscan.h"#include "assyms.h"#include "asexpr.h"#include "asparse.h"#include "bignum.h"#include "ascode.h"#include "asjxxx.h"#include "asio.h"#include "asmain.h"#include "iow.h"#include "asinclude.h"/******************************************* To catch the file name associate with * the .file compiler instrc. */extern	char	VectInclFileName [IndxMaxIFN-1][SizeFileNameVI];   extern	int		IndxVectFN;	   	  /* Index of the vector */extern	int		LastIndxVectFN;		/* Last index of the vector */Boolean FirstTimeIF = True;   /* To jump the first passage in IFILE *//*******************************************/extern int is_boot_file;	/* RTB 22/6/93 boolean. Whether a .boot directive has been encountered */long	lgensym[10];char	genref[10];long	bitfield;long	bitoff;long	curlen;			/* current length of literals *//* *	The following three variables are communication between various *	modules to special case a number of things.  They are properly *	categorized as hacks. */extern	struct	symtab *lastnam;/*last name seen by the lexical analyzer*/long	exprisname;		/*last factor in an expression was a name*/long	droppedLP;		/*one is analyzing an expression beginning with*/				/*a left parenthesis, which has already been*/				/*shifted. (Used to parse (<expr>)(rn)*/char	yytext[NCPName+2];	/*the lexical image*/extern long	yylval;			/*the lexical value; sloppy typing*/extern struct	Opcode		yyopcode;	/* lexical value for an opcode */extern Bignum	yybignum;		/* lexical value for a big number *//* *	Expression and argument managers */struct	exp	*xp;		/*next free expression slot, used by expr.c*/struct	exp	explist[NEXP];	/*max of 20 expressions in one opcode*/struct	arg	arglist[NARG];	/*building up operands in instructions*//* *	Sets to accelerate token discrimination */char	tokensets[(LASTTOKEN) - (FIRSTTOKEN) + 1];char	UDotsname[64];	/*name of the assembly source*/extern char *bit_map;	/* 	 *	MAC PORT!  	 *	For each label, we want the type and length (if appropriate).	 *	So we save the last label obtained for a possible future	 *	(immediate future!!) declaration.  The n_other and n_desc	 *	fields in the symbol table are used to store the type and	 *	length respectively.  If the dec is just there by itself, we	 *	create a symbol table entry, which has a null name.	 */static long last_address;long pass1_count = 0; /* @@ count of number of times "enter_symtab_details" is called*/long pass2_count = 0; /*count of number of times "patch_symtab_details" is called*/	/*MAC PORT!	 * "enter_symtab_details" records the data needed for macvax to more completely	 * disassemble the object file.	 */void enter_symtab_details(	struct symtab *last_label,	unsigned long declaration_type,	unsigned char fill_size,	unsigned short item_size){char hold_yytext[NCPName+2]; /*cludge*/#ifdef DEBUG2		iowprintf("\nenter_symtab_details: Last address: 0x%x, dotp->e_xvalue: 0x%x\n        last_label->s_type 0x%x, e_xtype 0x%x\n",		last_address, dotp->e_xvalue, last_label ? last_label->s_type:0, dotp->e_xtype);#endif		pass1_count++;		if( !last_label )		{#ifdef DEBUG2				iowprintf(" Generate our own label for this call\n");#endif				/* create a new dummy label for this object */			strncpy(hold_yytext,yytext,NCPName+1);	/* save yytext */			sprintf(yytext,":X%d",pass1_count);		/* @@ */				last_label = *lookup(passno == 1);			strncpy(yytext, hold_yytext, NCPName+1); /* restore yytext*/						last_label->s_index = dotp-usedot;	/*Index into the usedot array*/			last_label->s_type = dotp->e_xtype;  /*set expression type */			last_label->s_value = last_address;	  /*ie. dot before parsing this*/			}		if(declaration_type & 0xffffffe0)			iowprintf("This should be happening: declaration_type %d has high bits set\n",declaration_type);		if(fill_size & 0xf8)			iowprintf("This should be happening: fill_size %d has high bits set\n",fill_size);		last_label->s_other = ((unsigned char) ((declaration_type << 3) & 0xf8)) | (fill_size & 0x7);	/*record this as a .entry*/		last_label->s_desc = item_size; /*size of the item*/#ifdef DEBUG2		iowprintf("enter_symtab_details:%s\n        s_type 0x%x\n        s_value 0x%x\n",				((struct strdesc *)(last_label->s_name))->sd_string, last_label->s_type,last_label->s_value);#endif}	/*MAC PORT!	 * "patch_symtab_details" patches the addresses of symbol table entries created in 	 * "enter_symtab_details".	 */void patch_symtab_details(	struct symtab *last_label){char hold_yytext[NCPName+2]; /*cludge*/		pass2_count++;	if(!last_label && passno == 2)	{				strncpy(hold_yytext,yytext,NCPName+1);	/* save yytext */		sprintf(yytext,":X%d",pass2_count);	/*recreate dummy label*/#ifdef DEBUG2			iowprintf(" REGenerated our own label for this call %s\n", yytext);#endif		if((last_label = *lookup(0)) == 0) /*Looks up label yytext*/		{			iowprintf("can't find label %s\n",yytext);   /* @@ */			return;		}#ifdef DEBUG2		else			iowprintf("         found label \"%s\"\n", last_label->s_name);#endif		strncpy(yytext, hold_yytext, NCPName+1); /* restore yytext*/					last_label->s_name = ( char * )savestr( "\0", 0, STR_BOTH );  /*loose label*/		last_label->s_type &= ~(XTYPE|XFORW); /*Hmm*/		last_label->s_type |= dotp->e_xtype;  /*set expression type */		last_label->s_value = last_address;	  /*ie. dot before parsing this*/	}#ifdef DEBUG2	iowprintf("\nPatch_symtab_details:%s\n        s_type 0x%x\n        s_value 0x%x\n",((struct strdesc *)(last_label->s_name))->sd_string, last_label->s_type,last_label->s_value);#endif}	void yyparse(void){	reg	struct	exp	*locxp;		/*		 *	loc1xp and ptrloc1xp are used in the		 * 	expression lookahead		 */		struct	exp	*loc1xp;	/*must be non register*/		struct	exp	**ptrloc1xp = & loc1xp;		struct	exp	*pval;		/*hacking expr:expr*/	reg	struct	symtab	*np;	reg	long		argcnt;	reg	inttoktype	val;		/*what yylex gives*/	reg	inttoktype	auxval,auxauxval;		/*saves val, saves saved val*/	reg	struct 	arg	*ap;		/*first free argument*/	reg	struct	symtab	*p;	reg	struct	symtab	*stpt;		struct	strdesc *stringp;	/*handles string lists*/		long	regno;		/*handles arguments*/		long	*ptrregno = &regno;		long	sawmul;		/*saw * */		long	sawindex;	/*saw [rn]*/		long	sawsize;		long	seg_type; 	/*the kind of segment: data or text*/		long	seg_number;	/*the segment number*/		long tempvalue;		long	space_value;	/*how much .space needs*/		long	fill_rep;	/*how many reps for .fill */		long	fill_size;	/*how many bytes for .fill */		long	field_width;	/*how wide a field is to be*/		long	field_value;	/*the value to stuff in a field*/		char	*stabname;	/*name of stab dealing with*/		ptrall	stabstart;	/*where the stab starts in the buffer*/		long	reloc_how;	/* how to relocate expressions */		long	toconv;		/* how to convert bignums */		long	incasetable;	/* set if in a case table */			/* 	 *	MAC PORT!  	 *	For each label, we want the type and length (if appropriate).	 *	So we save the last label obtained for a possible future	 *	(immediate future!!) declaration.  The n_other and n_desc	 *	fields in the symbol table are used to store the type and	 *	length respectively.  If the dec is just there by itself, we	 *	create a symbol table entry, which has a null name.	 */	 struct symtab *last_label;	 long last_length;	 	 short mask;  /* for generating register masks */	 	 long tval;	/* for blkb, blkw, blkl */		u_long unrelocated_address;	#ifdef DEBUG	iowprintf("yyparse()\n");#endif	incasetable = 0;	xp = explist;	ap = arglist;		val = yylex();    while (val != PARSEEOF){	/* primary loop */		last_label = NULL;		/* no last label for this line yet */	last_address = dotp->e_xvalue; /* the address */		/* note the current location as an instruction begining */	/* RTB 15/7/93 Make sure that bit map is set relative to the origin by */	/* subtracting the code_base_address on the second pass */	unrelocated_address = dotp->e_xvalue;	if (passno==2)		unrelocated_address -= code_base_address;	if( passno == 2 && unrelocated_address < tsize )	{		/* only do this if we are still in the instruction space */		bit_map[ unrelocated_address>>3 ] |=  1 << (unrelocated_address & 0x7);#ifdef DEBUG		iowprintf(  "bitmap: set bit %d in byte %d at loc %x\n", unrelocated_address & 0x7,unrelocated_address>>3,			dotp->e_xvalue);#endif	}	while (INTOKSET(val, LINSTBEGIN)){#ifdef DEBUG		iowprintf(  "Head of skip line and label find loop\n" );#endif		if (val == INT) {		long i;#ifdef DEBUG		iowprintf(  "INT label\n" );#endif			i = ((struct exp *)yylval)->e_xvalue;			shift;			if (val != COLON){				yyerror("Local label %d is not followed by a ':' for a label definition",					i);				goto  errorfix;			}			if (i < 0 || i > 9) {				yyerror("Local labels are 0-9");				goto errorfix;			}			(void)sprintf(yytext, "L%d\001%d", i, lgensym[i]);			lgensym[i]++;			genref[i] = 0;			yylval = (long)*lookup(passno == 1);			val = NAME;			np = (struct symtab *)yylval;			goto restlab;		}		if (val == NL){			lineno++;			shift;		} else 		{	/*its a name, so we have a label or def */#ifdef DEBUG		iowprintf(  "Name label\n" );#endif			if (val != NAME){				ERROR("Name expected for a label");			}			np = (struct symtab *)yylval;			last_label = np;		/* aha. have a last_label */			shiftover(NAME);			if (val != COLON) {				yyerror("\"%s\" is not followed by a ':' for a label definition",					FETCHNAME(np));				goto  errorfix;			}restlab:			shift;			flushfield(NBWD/4);		/*	iowprintf(  "%ld\n%ld restlab\n",np->s_value,dotp->e_xvalue );  RTB */			if ((np->s_type&XTYPE)!=XUNDEF) {				if (  (np->s_type&XTYPE) != dotp->e_xtype 				   || np->s_value != dotp->e_xvalue				   || (   passno == 1				       && np->s_index != dotp->e_xloc) ) {					if (passno == 1)						yyerror("%s redefined",							FETCHNAME(np));					else						yyerror("%s redefined: PHASE ERROR, 1st: %d, 2nd: %d",							FETCHNAME(np),							np->s_value,							dotp->e_xvalue);				}			}			np->s_type &= ~(XTYPE|XFORW);			np->s_type |= dotp->e_xtype;			np->s_value = dotp->e_xvalue;			if (passno == 1){				np->s_index = dotp-usedot;				if (FETCHNAME(np)[0] == 'L'){					nlabels++;				}				np->s_tag = LABELID;			}		}	/*end of this being a label*/	}	/*end of consuming all labels, NLs */ 	xp = explist;	ap = arglist;		#ifdef DEBUG		iowprintf(  "Entering switch on token\n" );#endif	/*	 *	process the INSTRUCTION body	 */	switch(val){    default:	ERROR("Unrecognized instruction or directive"); 	case IABORT:	shift;	sawabort(); 	/*NOTREACHED */	case IBOOT:	/* RTB 22/6/93 */		shift;		is_boot_file = 1;		break;/* case IINCLUDE: *//*	break; */   case PARSEEOF:	tokptr -= sizeof(bytetoktype);	*tokptr++ = VOID;	tokptr[1] = VOID;	tokptr[2] = PARSEEOF;	break;	/***************************************************************	*  ## The only place in all the program where we have an evident	* test on an IFILE compiler directive.	*  This case is not meet at all during the first pass =>	*  error message on the appended file name.	*/#define not_laurents_code   case IFILE:		shift;		stringp = (struct strdesc *)yylval;#ifdef BSD_ORIG_CODE /*original buggy code from BSD*/		shiftover(STRING);		dotsname = &UDotsname[0];		movestr(dotsname, stringp->sd_string,		min(stringp->sd_strlen, sizeof(UDotsname)));		break;#else#ifdef laurents_code /*Uses prepass code to save filename instead of fixing the bug*/		shiftover(STRING);					/**********************************		*  Assign the correct file name		*/		if  (FirstTimeIF)		{			FirstTimeIF = False;			IndxVectFN = 0;			strcpy (dotsname, VectInclFileName [IndxVectFN]);		}		else		{			strcpy (dotsname, VectInclFileName [IndxVectFN]);			if  (IndxVectFN < IndxMaxIFN)			{				if  (IndxVectFN < LastIndxVectFN)					++IndxVectFN;				else				{					IndxVectFN = 0;					FirstTimeIF = True;  /* To start again at the begining of the file */				}			}			else				iowprintf ("Too many .file\n");		}		break;#else /*Fix to BSD code R.B. 1.10.92*/		dotsname = UDotsname;		{		int i;			i = min(stringp->sd_strlen, sizeof(UDotsname) - 1);			if (stringp->sd_place & STR_CORE)			{				movestr(dotsname, stringp->sd_string, i);			} 			else 			{				/* must not rewind file as if we are on the first pass */				/* lexical analysis may not have finished and we still need */				/* to add items to the string file. */				long oldpos = mftell(strfile);		/* save the position */				mfseek(strfile, stringp->sd_stroff, 0);				mfread(dotsname,  1,  i, strfile);				mfseek(strfile, oldpos, 0);			/* restore the position */			}			dotsname[i] = '\0';		}		shiftover(STRING);		/* iowprintf("File: %s \n",dotsname); */		break;#endif#endif   case ILINENO:	shift;		/*over the ILINENO*/	expr(locxp, val, asparse_err());	lineno = locxp->e_xvalue;	break;   case ISET: 	/* .set  <name> , <expr> */	shift;	np = (struct symtab *)yylval;	shiftover(NAME);	shiftover(CM);	expr(locxp, val, asparse_err());#ifdef DEBUG		iowprintf(  "ISET finished expr(locxp, val, asparse_err());\n" );#endif	np->s_type &= (XXTRN|XFORW);	np->s_type |= locxp->e_xtype&(XTYPE|XFORW);	np->s_value = locxp->e_xvalue;#ifdef DEBUG		iowprintf(  "ISET finished np->s_value = locxp->e_xvalue;\n" );#endif	if (passno==1)		np->s_index = locxp->e_xloc;	if ((locxp->e_xtype&XTYPE) == XUNDEF)		yyerror("Illegal set?");#ifdef DEBUG		iowprintf(  "ISET finished\n" );#endif	break;		/* 	 *	a new directive added for the MAC port, so that	 *	we know where the register mask lies, for 	 *	disassembling purposes	 */   case IENTER:	/* .enter  <reglist> */   				/* reglist = empty | regnum, reglist | regnum */				/* regnum = r0, r1, r2, ... r15, iv, dv */						shift;	expr( locxp, val, asparse_err() );	mask = REVSHORT( locxp->e_number.num_num.numIl_int.Il_ushort[1] );	dotp->e_xvalue += 2;	if( passno == 1 )	{		enter_symtab_details(last_label, (unsigned long) IENTER ,							(unsigned char) 0, (unsigned short) dotp->e_xvalue - last_address);	}	else /*pass2*/	{			patch_symtab_details(last_label);			bwrite( (char *)&mask, 2, txtfil ); /*pass2 pre-existing stuff*/	}	break;		   case ILSYM: 	/*.lsym name , expr */	shift;	np = (struct symtab *)yylval;	shiftover(NAME);	shiftover(CM);	expr(locxp, val, asparse_err());	/*	 *	Build the unique occurance of the	 *	symbol.	 *	The character scanner will have	 *	already entered it into the symbol	 *	table, but we should remove it	 */	if (passno == 1){		stpt = (struct symtab *)symalloc();		stpt->s_name = np->s_name;		np->s_tag = IS_OBSOLETE;	/*invalidate original */		nforgotten++;		np = stpt;		if ( (locxp->e_xtype & XTYPE) != XABS)			yyerror("Illegal second argument to lsym");		np->s_value = locxp->e_xvalue;		np->s_type = XABS;		np->s_tag = ILSYM;	}	break;   case IGLOBAL: 	/*.globl <name> */	shift;	np = (struct symtab *)yylval;	shiftover(NAME);	np->s_type |= XXTRN;	break;   case IORIGIN: 	/*.origin <expr> */		shift;		expr(locxp, val, asparse_err());		if(passno==1)		{			if(dotp != &usedot[0] || dotp->e_xvalue != 0)				yyerror(".origin directive must only occur immediately after the first .code");			if (locxp->e_xvalue & BLOCKBOUND )				yyerror("Relocation address must fall on a block boundary");			code_base_address = locxp->e_xvalue;		}		break;   case ITEXT: 	/*.code [ <expr> ] */   case IDATA: 	/*.data [ <expr> ] */		seg_type = -val; /*this saves us a got expr flag. G */		shift;		if (INTOKSET(val, EBEGOPS+YUKKYEXPRBEG+SAFEEXPRBEG))		{			expr(locxp, val, asparse_err());			seg_type = -seg_type;   /*now, it is positive*/		}				if (seg_type < 0)		{	/*there wasn't an associated expr*/			seg_number = 0;			seg_type = -seg_type;		} 		else 		{			if(((locxp->e_xtype & XTYPE) != XABS)	/* tekmdp */			|| (seg_number = locxp->e_xvalue) >= NLOC) 			{				yyerror("illegal location counter");				seg_number = 0;			}		}		if (seg_type == IDATA)			seg_number += NLOC;		flushfield(NBWD/4);		dotp = &usedot[seg_number];		if (passno==2)		{	/* go salt away in pass 2*/			txtfil = usefile[seg_number];			relfil = rusefile[seg_number];		}	break;	/*	 *	Storage filler directives:	 *	 *	.byte	[<exprlist>]	 *	 *	exprlist:  empty | exprlist outexpr	 *	outexpr:   <expr> | <expr> : <expr>	 */   case IBYTE:	curlen = NBWD/4; goto elist;   case IWORD:	curlen = NBWD/2; goto elist;   case IINT:	curlen = NBWD;   goto elist;   case ILONG:	curlen = NBWD;   goto elist;   elist:	tempvalue = val;	shift;		last_length = 0;  /* count the number of <expr>s */		/*	 *	Expression List processing	 */	if (INTOKSET(val, EBEGOPS+YUKKYEXPRBEG+SAFEEXPRBEG) || val == MASK){	    do{		/*		 *	expression list consists of a list of :		 *	<expr>		 *	<expr> : <expr> 		 *		(pack expr2 into expr1 bits		 */		expr(locxp, val, asparse_err());		/*		 *	now, pointing at the next token		 */		if (val == COLON){			shiftover(COLON);			expr(pval, val, asparse_err());			if ((locxp->e_xtype & XTYPE) != XABS) /* tekmdp */				yyerror("Width not absolute");			field_width = locxp->e_xvalue;			locxp = pval;			if (bitoff + field_width > curlen)				flushfield(curlen);			if (field_width > curlen)				yyerror("Expression crosses field boundary");		} else {			field_width = curlen;			flushfield(curlen);		}		if ((locxp->e_xtype & XTYPE) != XABS) {			if (bitoff)				yyerror("Illegal relocation in field");			switch(curlen){				case NBWD/4:	reloc_how = TYPB; break;				case NBWD/2:	reloc_how = TYPW; break;				case NBWD:	reloc_how = TYPL; break;			}			if (passno == 1){				dotp->e_xvalue += ty_nbyte[reloc_how];			} else {				outrel(locxp, reloc_how);			}		} else {			/*			 *				 *	See if we are doing a case instruction.			 *	If so, then see if the branch distance,			 *	stored as a word,			 *	is going to loose sig bits.			 */			if (passno == 2 && incasetable){				if (  (locxp->e_xvalue < -32768)				    ||(locxp->e_xvalue > 32767)){					yyerror("Case will branch too far");				}			}			field_value = locxp->e_xvalue & ( (1L << field_width)-1);			bitfield |= field_value << bitoff;			bitoff += field_width;		}		xp = explist;		if (auxval = (val == CM)) //Yes one ='s			shift;	    } while (auxval);	}	/* there existed an expression at all */	flushfield(curlen);	if ( ( curlen == NBWD/4) && bitoff)		dotp->e_xvalue ++;			/* we want NO .bss ==> no uninit data */	if( dotp->e_xvalue == last_address )	{		yyerror( 			"Implementation limitation: no .bss section ==> no uninitialised data" );		goto errorfix;	}		/* MAC PORT */	/* try to give more info in symtab about object */	if( passno == 1 )	{		enter_symtab_details( last_label, (unsigned long) tempvalue,				(unsigned char) 0, (unsigned short) dotp->e_xvalue - last_address);	}	else				patch_symtab_details(last_label);	break;	/*end of case IBYTE, IWORD, ILONG, IINT*/   case ISPACE: 	/* .space <expr> */   	auxval = val;	shift;	expr(locxp, val, asparse_err());	if ((locxp->e_xtype & XTYPE) != XABS)	/* tekmdp */		yyerror("Space size not absolute");	space_value = locxp->e_xvalue;  ospace:	flushfield(NBWD/4);	{		static char spacebuf[128];		while (space_value > sizeof(spacebuf))		{			outs(spacebuf, sizeof(spacebuf));			space_value -= sizeof(spacebuf);		}		outs(spacebuf, space_value);	}	/* MAC PORT */	/* try to give more info in symtab about object */	if( passno == 1 )	{			enter_symtab_details( last_label,(unsigned long) auxval, 						(unsigned char) 0, (unsigned short) space_value);	}	else					patch_symtab_details(last_label);	break;	/*	 *	.fill rep, size, value	 *	repeat rep times: fill size bytes with (truncated) value	 *	size must be between 1 and 8	 */   case	IFILL:   case BLKB:   case BLKW:   case BLKL:   tval = val;	shift;	expr(locxp, val, asparse_err());	if ( (locxp->e_xtype & XTYPE) != XABS)	/* tekmdp */		yyerror("Fill repetition count not absolute");	fill_rep = locxp->e_xvalue;	if( tval == IFILL )	{		shiftover(CM);		expr(locxp, val, asparse_err());		if ( (locxp->e_xtype & XTYPE) != XABS)	/* tekmdp */			yyerror("Fill size not absolute");		fill_size = locxp->e_xvalue;		if (fill_size <= 0 || fill_size > 8)			yyerror("Fill count not in in 1..8");		shiftover(CM);		expr(locxp, val, asparse_err());		if (passno == 2 && (locxp->e_xtype & XTYPE) != XABS)	/* tekmdp */			yyerror("Fill value not absolute");		flushfield(NBWD/4);				dotp->e_xvalue += fill_rep * fill_size;		if (passno == 2) {			/* RTB 13/7/93 hack to make sure .fill values get reversed for the MAC */			int k;			/* overkill do it for up to octals */			for(k=0;k!=CH_N;k++)				locxp->e_number.num_num.numIq_int.Iq_ulong[k] =					REVLONG(locxp->e_number.num_num.numIq_int.Iq_ulong[k]);#ifdef freddie			locxp->e_xvalue = REVLONG(locxp->e_xvalue);#endif			while(fill_rep-- > 0)				bwrite((char *)&locxp->e_xvalue, fill_size, txtfil);		}	}	else	{		long fill_val;		switch( tval )		{			case BLKB : fill_size = 1;						break;			case BLKW : fill_size = 2;						break;			case BLKL:  fill_size = 4;						break;		}		fill_val = 0;				dotp->e_xvalue += fill_rep * fill_size;		if (passno == 2) {			while(fill_rep-- > 0)				bwrite((char *)&fill_val, fill_size, txtfil);		}	}			/* MAC PORT */	/* try to give more info in symtab about object */	if( passno == 1 )	{		enter_symtab_details(last_label,(unsigned long) IFILL,		(unsigned char) (fill_size - 1), (unsigned short) (fill_rep * fill_size) );	}	else		patch_symtab_details(last_label);	break;   case IASCII:		/* .ascii [ <stringlist> ] */   case IASCIZ: 	/* .asciz [ <stringlist> ] */	auxval = val;	shift;	/*	 *	Code to consume a string list	 *	 *	stringlist: empty | STRING | stringlist STRING	 */	 	/* we (on the MAC) will NOT have empty string lists */	if( val != STRING )	{		yyerror( 			"Implementation limitation: no .bss section ==> no uninitialised data" );		goto errorfix;	}	while (val == STRING){		long	mystrlen;		flushfield(NBWD/4);		if (bitoff)			dotp->e_xvalue++;		stringp = (struct strdesc *)yylval;		/*		 *	utilize the string scanner cheat;		 *	the scanner appended a null byte on the string,		 *	but didn't charge it to sd_strlen		 */		mystrlen = stringp->sd_strlen;		mystrlen += (auxval == IASCIZ) ? 1 : 0;		if (passno == 2){			if (stringp->sd_place & STR_CORE){				outs(stringp->sd_string, mystrlen);			} else {				long	i, nread;				mfseek(strfile, stringp->sd_stroff, 0);				for (i = 0; i < mystrlen;/*VOID*/){					nread = mfread(yytext, 1,						min(mystrlen - i,						  sizeof(yytext)), strfile);					outs(yytext, nread);					i += nread;				}			}		} else {			dotp->e_xvalue += mystrlen;		}		/* MAC PORT */		/* try to give more info in symtab about object */		if( passno == 1 )		{			enter_symtab_details(last_label,(unsigned long ) auxval,						(unsigned char) 0, (unsigned short) mystrlen);		}		else			patch_symtab_details(last_label);		/*don't try to use last label again in multiple strings */		last_label = NULL;		shift;		/*over the STRING*/		if (val == CM)	/*could be a split string*/			shift;	}	break;	   case IORG: 	/* .org <expr> */   	auxval = val;	shift;	expr(locxp, val, asparse_err());	if ((locxp->e_xtype & XTYPE) == XABS)	/* tekmdp */		orgwarn++;	else if ((locxp->e_xtype & ~XXTRN) != dotp->e_xtype)		yyerror("Illegal expression to set origin");	space_value = locxp->e_xvalue - dotp->e_xvalue;	if (space_value < 0)		yyerror("Backwards 'org'");	goto ospace;	break;/* * *	Process stabs.  Stabs are created only by the f77 *	and the C compiler with the -g flag set. *	We only look at the stab ONCE, during pass 1, and *	virtually remove the stab from the intermediate file *	so it isn't seen during pass2.  This makes for some *	hairy processing to handle labels occuring in *	stab entries, but since most expressions in the *	stab are integral we save lots of time in the second *	pass by not looking at the stabs. *	A stab that is tagged floating will be bumped during *	the jxxx resolution phase.  A stab tagged fixed will *	not be be bumped. * *	.stab:	Old fashioned stabs *	.stabn: For stabs without names *	.stabs:	For stabs with string names *	.stabd: For stabs for line numbers or bracketing, *		without a string name, without *		a final expression.  The value of the *		final expression is taken to be  the current *		location counter, and is patched by the 2nd pass * *	.stab{<expr>,}*NCPName,<expr>, <expr>, <expr>, <expr> *	.stabn		 <expr>, <expr>, <expr>, <expr> *	.stabs   STRING, <expr>, <expr>, <expr>, <expr> *	.stabd		 <expr>, <expr>, <expr> # .  */   case ISTAB: 	yyerror(".stab directive no longer supported");	goto errorfix;  tailstab:	expr(locxp, val, asparse_err());	if (! (locxp->e_xvalue & STABTYPS)){		yyerror("Invalid type in %s", stabname);		goto errorfix;	}	stpt->s_ptype = locxp->e_xvalue;	shiftover(CM);	expr(locxp, val, asparse_err());	stpt->s_other = locxp->e_xvalue;	shiftover(CM);	expr(locxp, val, asparse_err());	stpt->s_desc = locxp->e_xvalue;	shiftover(CM);	exprisname = 0;	expr(locxp, val, asparse_err());	p = locxp->e_xname;	if (p == NULL) {	/*absolute expr to begin with*/		stpt->s_value = locxp->e_xvalue;		stpt->s_index = dotp - usedot;		if (exprisname){			stpt->s_type = locxp->e_xtype;			switch(stpt->s_ptype){				case N_GSYM:				case N_FNAME:				case N_RSYM:				case N_SSYM:				case N_LSYM:				case N_PSYM:				case N_BCOMM:				case N_ECOMM:				case N_LENG:					stpt->s_tag = STABFIXED;					break;				default:					stpt->s_tag = STABFLOATING;					break;			}		} else			stpt->s_tag = STABFIXED;	}	else {		/*really have a name*/		stpt->s_dest = locxp->e_xname;		stpt->s_index = p->s_index;		stpt->s_type = p->s_type | STABFLAG;		/*		 *	We will assign a more accruate		 *	guess of locxp's location when		 *	we sort the symbol table		 *	The final value of value is		 *	given by stabfix()		 *//* * For exprs of the form (name + value) one needs to remember locxp->e_xvalue * for use in stabfix. The right place to keep this is in stpt->s_value * however this gets corrupted at an unknown point. * As a bandaid hack the value is preserved in s_desc and s_other (a * short and a char). This destroys these two values and will * be fixed. May 19 ,1983 Alastair Fyfe */		if(locxp->e_xvalue) {			stpt->s_other = (locxp->e_xvalue >> 16);			stpt->s_desc =  (locxp->e_xvalue  & 0x0000ffff);			stpt->s_tag = STABFLOATING;		}	}	/*	 *	tokptr now points at one token beyond	 *	the current token stored in val and yylval,	 *	which are the next tokens after the end of	 *	this .stab directive.  This next token must	 *	be NL, so is of width just	 *	one.  Therefore, to point to the next token	 *	after the end of this stab, just back up one..	 */	buildskip(stabstart, (bytetoktype *)tokptr - sizeof(bytetoktype));	break;	/*end of the .stab*/   case ISTABDOT:   	yyerror(".stabd directive no longer supported");	goto errorfix;	stabname = ".stabd";	stpt = (struct symtab *)yylval;	/*	 *	We clobber everything after the	 *	.stabd and its pointer... we MUST	 *	be able to get back to this .stabd	 *	so that we can resolve its final value	 */	stabstart = tokptr;	shift;		/*over the ISTABDOT*/	if (passno == 1){		expr(locxp, val, asparse_err());		if (! (locxp->e_xvalue & STABTYPS)){			yyerror("Invalid type in .stabd");			goto errorfix;		}		stpt->s_ptype = locxp->e_xvalue;		shiftover(CM);		expr(locxp, val, asparse_err());		stpt->s_other = locxp->e_xvalue;		shiftover(CM);		expr(locxp, val, asparse_err());		stpt->s_desc = locxp->e_xvalue;		/*		 *		 *	Now, clobber everything but the		 *	.stabd pseudo and the pointer		 *	to its symbol table entry		 *	tokptr points to the next token,		 *	build the skip up to this		 */		buildskip(stabstart, (bytetoktype *)tokptr - sizeof(bytetoktype));	}	/*	 *	pass 1:	Assign a good guess for its position	 *		(ensures they are sorted into right place)/	 *	pass 2:	Fix the actual value	 */	stpt->s_value = dotp->e_xvalue;	stpt->s_index = dotp - usedot;	stpt->s_tag = STABFLOATING;	/*although it has no effect in pass 2*/	break;   case ISTABNONE:    yyerror(".stabn directive no longer supported");	goto errorfix;	stabname = ".stabn"; goto shortstab;   case ISTABSTR:	yyerror(".stabs directive no longer supported");	goto errorfix;	stabname = ".stabs";   shortstab:	auxval = val;	if (passno == 2) goto errorfix;	stpt = (struct symtab *)yylval;	stabstart = tokptr;	(bytetoktype *)stabstart -= sizeof(struct symtab *);	(bytetoktype *)stabstart -= sizeof(bytetoktype);	shift;	if (auxval == ISTABSTR){		stringp = (struct strdesc *)yylval;		shiftover(STRING);		stpt->s_name = (char *)stringp;		/*		 *	We want the trailing null included in this string.		 *	We utilize the cheat the string scanner used,		 *	and merely increment the string length		 */		stringp->sd_strlen += 1;		shiftover(CM);	} else {		stpt->s_name = (char *)savestr("\0", 0, STR_BOTH);	}	goto tailstab;	break;   case ICOMM:		/* .comm  <name> , <expr> */   case ILCOMM: 	/* .lcomm <name> , <expr> */	auxval = val;	shift;	np = (struct symtab *)yylval;	shiftover(NAME);	shiftover(CM);	expr(locxp, val, asparse_err());	if ( (locxp->e_xtype & XTYPE) != XABS)	/* tekmdp */		yyerror("comm size not absolute");	if (passno == 1 && (np->s_type&XTYPE) != XUNDEF)		yyerror("Redefinition of %s", FETCHNAME(np));	if (passno==1) {		np->s_value = locxp->e_xvalue;		if (auxval == ICOMM) 			np->s_type |= XXTRN;		else 		{			np->s_type &= ~XTYPE;			np->s_type |= XBSS;		}	}	break;   case IALIGN: 		/* .align <expr> */	stpt = (struct symtab *)yylval;	shift;	expr(locxp, val, asparse_err());	jalign(locxp, stpt);	break;   case INST0: 		/* instructions w/o arguments*/	incasetable = 0;	insout(yyopcode, (struct arg *)0, 0);	shift;		break;   case INSTn:		/* instructions with arguments*/   case IJXXX: 		/* UNIX style jump instructions */	auxval = val;	/*	 *	Code to process an argument list	 */	ap = arglist;	xp = explist;		shift;		/* bring in the first token for the arg list*/	for (argcnt = 1; argcnt <= 6; argcnt++, ap++){		/*		 *	code to process an argument proper		 */	    sawindex  = sawmul = sawsize = 0;	    {		switch(val) {		   default:		     disp:			if( !(INTOKSET(val,				 EBEGOPS				+YUKKYEXPRBEG				+SAFEEXPRBEG)) ) {				ERROR("expression expected");			}			expr(ap->a_xp,val, asparse_err());		     overdisp:			if ( val == LP || sawsize){				shiftover(LP);				findreg(regno);				shiftover(RP);				ap->a_atype = ADISP;				ap->a_areg1 = regno;			} else {				ap->a_atype = AEXP;				ap->a_areg1 = 0;			}			goto index;		   case SIZESPEC: 		     sizespec:			sawsize = yylval;			shift;			goto disp;		   case REG:		   case REGOP: 			findreg(regno);			ap->a_atype = AREG;			ap->a_areg1 = regno;			break;		    		   case MUL: 		   case PTR: 			sawmul = 1;			shift;			if (val == LP) goto base;			if (val == LITOP_VMS || val == LITOP_UNIX ) goto imm;			if (val == SIZESPEC) goto sizespec;			if (INTOKSET(val,				 EBEGOPS				+YUKKYEXPRBEG				+SAFEEXPRBEG)) goto disp;			ERROR("expression, '(' or '$' expected");			break;		   case LP: 		     base:			shift;	/*consume the LP*/			/*			 *	hack the ambiguity of			 *	movl (expr) (rn), ...			 *	note that (expr) could also			 *	be (rn) (by special hole in the			 *	grammar), which we ensure			 *	means register indirection, instead			 *	of an expression with value n			 */			if (val != REG && val != REGOP){				droppedLP = 1;				val = exprparse(val, &(ap->a_xp));				droppedLP = 0;				goto overdisp;			}			findreg(regno);			shiftover(RP);			if (val == PLUS){				shift;				ap->a_atype = AINCR;			} else				ap->a_atype = ABASE;			ap->a_areg1 = regno;			goto index;		   case LITOP_UNIX: 		   case LITOP_VMS: 		      imm:			shift;			expr(locxp, val, asparse_err());			ap->a_atype = AIMM;			ap->a_areg1 = 0;			ap->a_xp = locxp;			goto index;					   case MASK:		   	expr( locxp, val, asparse_err() );			ap->a_atype = AIMM;			ap->a_areg1 = 0;			ap->a_xp = locxp;			goto index;					   case MP: 			shift;	/* -(reg) */			findreg(regno);			shiftover(RP);			ap->a_atype = ADECR;			ap->a_areg1 = regno;	  index:			/*look for [reg] */			if (val == LB){				shift;				findreg(regno);				shiftover(RB);				sawindex = 1;				ap->a_areg2 = regno;			}			break;		}	/*end of the switch to process an arg*/	    }	/*end of processing an argument*/	    if (sawmul){			/*			 * Make a concession for *(%r)			 * meaning *0(%r) 			 */			if (ap->a_atype == ABASE) {				ap->a_atype = ADISP;				xp->e_xtype = XABS;				xp->e_number = Znumber;				xp->e_number.num_tag = TYPL;				xp->e_xloc = 0;				ap->a_xp = xp++;			}			ap->a_atype |= ASTAR;			sawmul = 0;	    }	    if (sawindex){		ap->a_atype |= AINDX;		sawindex = 0;	    }	    ap->a_dispsize = sawsize == 0 ? d124 : sawsize;		if (val != CM) break;		shiftover(CM);	}	/*processing all the arguments*/	if (argcnt > 6){		yyerror("More than 6 arguments");		goto errorfix;	}	/*	 *	See if this is a case instruction,	 *	so we can set up tests on the following	 *	vector of branch displacements	 */	if (yyopcode.Op_eopcode == CORE){		switch(yyopcode.Op_popcode){		case 0x8f:	/* caseb */		case 0xaf:	/* casew */		case 0xcf:	/* casel */			incasetable++;			break;		default:			incasetable = 0;			break;		}	}	insout(yyopcode, arglist,		auxval == INSTn ? argcnt : - argcnt);	break;   case IQUAD:		toconv = TYPQ;	goto bignumlist;   case IOCTA:		toconv = TYPO;	goto bignumlist;   case IFFLOAT:	toconv = TYPF;	goto bignumlist;   case IDFLOAT:	toconv = TYPD;	goto bignumlist;   case IGFLOAT:	toconv = TYPG;	goto bignumlist;   case IHFLOAT:	toconv = TYPH;	goto bignumlist;   bignumlist:   auxauxval = auxval = val;	/*	 *	eat a list of non 32 bit numbers.	 *	IQUAD and IOCTA can, possibly, return	 *	INT's, if the numbers are "small".	 *	 *	The value of the numbers is coming back	 *	as an expression, NOT in yybignum.	 */	shift;	/* over the opener */	if ((val == BIGNUM) || (val == INT)){		do{			if ((val != BIGNUM) && (val != INT)){				ERROR(ty_float[toconv]				   ? "floating number expected"				   : "integer number expected" );			}			dotp->e_xvalue += ty_nbyte[toconv];			if (passno == 2){				bignumwrite(					((struct exp *)yylval)->e_number,					toconv);			}			xp = explist;			shift;		/* over this number */			if (auxval = (val == CM)) //Yes one ='s				shift;	/* over the comma */		} while (auxval);	/* as long as there are commas */	}	else	{		/* on the MAC we have no .bss section */		yyerror( 			"Implementation limitation: no .bss section ==> no uninitialised data" );		goto errorfix;	}		/* MAC PORT */	/* try to give more info in symtab about object */	if( passno == 1 )	{		enter_symtab_details(last_label,(unsigned long) auxauxval,					(unsigned char) 0, (unsigned short) 0);		if( dotp->e_xvalue == last_address )		{			/*			 *	uninit data ==> pc not moved.  			 *	this is set up as a special case for the unix linker			 */			last_label->s_desc = ty_nbyte[ toconv ] / 8;  /* to get bytes */		}		else		{			/*			 *	init data ==> pc moved.			 */			last_label->s_desc = dotp->e_xvalue - last_address;		}	}	else				patch_symtab_details(last_label);	break;	/* end of the case for initialized big numbers */    }	/*end of the switch for looking at each reserved word*/	continue;   errorfix: 	/*	 *	got here by either requesting to skip to the	 *	end of this statement, or by erroring out and	 *	wanting to apply panic mode recovery	 */	while (    (val != NL) 		&& (val != PARSEEOF)	      ){		shift;	}	if (val == NL)		lineno++;	shift;    }	/*end of the loop to read the entire file, line by line*/}	/*end of yyparse*/	/* *	Process a register declaration of the form *	% <expr> * *	Note: *		The scanner has already processed funny registers of the form *	%dd[+-]*, where dd is a decimal number in the range 00 to 15 (optional *	preceding zero digit).  If there was any space between the % and *	the digit, the scanner wouldn't have recognized it, so we *	hack it out here. */inttoktype funnyreg (	/*what the read head will sit on*/	inttoktype	val,		/*what the read head is sitting on*/	long	*regnoback		/*call by return*/){	reg	struct	exp *locxp;		struct	exp *loc1xp;		struct	exp **ptrloc1xp = & loc1xp;	expr(locxp, val, return(0));	/*and leave the current read head with value*/	if ( (passno == 2) &&	    (   (locxp->e_xtype & XTYPE) != XABS	     || (locxp->e_xvalue < 0)	     || (locxp->e_xvalue >= 16)	    )	  ){		yyerror("Illegal register");		return(0);	}	*regnoback = locxp->e_xvalue;	return(val);} /* *	Shift over error */void shiftoerror(	long	token){	yyerror("%s expected", tok_to_name(token),0,0,0,0);}/*VARARGS1*/void yyerror   /* @@ */(	char *s,	...){unsigned long * a1 = (unsigned long *)&s + 1;unsigned long * a2 = (unsigned long *)&s + 2;unsigned long * a3 = (unsigned long *)&s + 3;unsigned long * a4 = (unsigned long *)&s + 4;unsigned long * a5 = (unsigned long *)&s + 5;	if (anyerrs == 0 && anywarnings == 0 && ! silent) 		iowprintf( "Assembler:\n");	anyerrs++;	if (silent)		return;		    /* ## */	iowprintf( "\"%s\", line %d: ", dotsname, lineno);	iowprintf( s, *a1, *a2,*a3,*a4,*a5);	iowprintf( "\n");}/*VARARGS1*/void yywarning(	char *s,	...){unsigned long * a1 = (unsigned long *)&s + 1;unsigned long * a2 = (unsigned long *)&s + 2;unsigned long * a3 = (unsigned long *)&s + 3;unsigned long * a4 = (unsigned long *)&s + 4;unsigned long * a5 = (unsigned long *)&s + 5;	if (anyerrs == 0 && anywarnings == 0 && ! silent) 		iowprintf( "Assembler:\n");	anywarnings++;	if (silent)		return;	iowprintf( "\"%s\", line %d: WARNING: ", dotsname, lineno);	iowprintf( s, *a1, *a2,*a3,*a4,*a5);	iowprintf( "\n");}/*  *	evaluate masks of the form  *		^M<reglist> *		reglist = empty | regnum | , regnum *		regnum  = r2, ... r11, iv, dv * *	If there were any errors, then (long) -1 is returned. *	-1 is an impossible value, as it is 32 bits.  We can *	otherwise only have 16 bits set. */long maskparse(	long val,	struct exp **ptr){	long mask = 0;	long regno;	long *ptrregno = &regno;		/* for register expressions */			shiftover( MASK );	shiftover( LSH );	if( val == RSH )	{		goto done;	}	while( 1 )	{		switch( val )		{			case REG:				findreg( regno );				if( regno > 15 )					mask |= 1 << (regno-2);				else					mask |= 1 << regno;				if( val == CM )					shift;				else					if ( val == RSH )					{						goto done;					}					else					{						yyerror( "Bad token in mask.  %d", val );						goto errorfix;					}				break;			case NL:				ERROR( "Missing or incorrect mask terminator" );			default:				ERROR( "Bad token in mask" );		}	}   errorfix: 	/*	 *	got here by either requesting to skip to the	 *	end of this statement, or by erroring out and	 *	wanting to apply panic mode recovery	 */	while (    (val != NL) 		&& (val != PARSEEOF)	      ){		shift;	}	if (val == NL)		lineno++;	shift;	mask = 0;	/* now return a sensible expression structure */	   done:	(*ptr) = xp++;	(*ptr)->e_xtype = XABS;	(*ptr)->e_number = Znumber;	(*ptr)->e_number.num_tag = TYPW;	(*ptr)->e_number.num_num.numIl_int.Il_ushort[1] = (short)mask;	return( val );}			