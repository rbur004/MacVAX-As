#include	<types.h>#include	<quickdraw.h>#include	<windows.h>#include	<dialogs.h>#include	<controls.h>#include	<toolutils.h>#include	<menus.h>#include 	<Files.h>#include 	<packages.h>#include	<segload.h>#include	<textedit.h>#include    <scrap.h>#include	<Events.h>#include	<OSutils.h>#include	<resources.h>#include 	<String.h>#include 	<Strings.h>#include	<memory.h>#define _DOCMDS_C_#include 	"mstdio.h"#include	"iow.h"#include 	"window.h"#include 	"main.h"#include 	"macio.h"#include 	"docmds.h"#include	"launch.h"#include 	"asmain.h"#include	"aprintf.h"#include	"asinclude.h"#pragma segment DOCMDS/******************************************************************* Open an existing file via the standard file box*/M_FILE *mopen_local(	char *ftype	/* types of files to display*/){struct Point 			dlgOrigin;			/* dialogbox top left corner*/static SFReply			theReply;			/* Data returned from dialogbox*/short 					num;				/* number of file types*/SFTypeList 				types;				/* file types*/char					*p;OSErr	error;	wprintf ("@@@ Start mopen_local\n");		dlgOrigin.h = DLGLEFT;	dlgOrigin.v = DLGTOP;				for (p = (char *) types, num = 0; *ftype && num < 16; num++ )		*p++ = *ftype++;					num /= 4;	SFGetFile(dlgOrigin,(void *)"", (FileFilterProcPtr) 0, num, types, (DlgHookProcPtr)0, &theReply);	if(theReply.good)	{			p2cstr(theReply.fName); 					return( mfopen (  (char *)&theReply.fName,  theReply.vRefNum, "r"    ) ) ;	}	return((M_FILE *)0);} /* mopen_local *//*******************************************************************  Copy the second Id to the first.*/void  CopySecToFirst(M_FILE  *First, M_FILE  *Second){  First->_cnt = Second->_cnt;  First->_ptr = Second->_ptr;  First->_base = Second->_base;  First->_bufsiz = Second->_bufsiz;  First->_flag = Second->_flag;  First->_file = Second->_file;  First->vrefnum = Second->vrefnum;  strcpy (First->name,Second->name);} /* CopySecToFirst *//*******************************************************************/MFILE *mopen_na_LFR(	char *name,		short vrefnum){MFILE 	*fp;				/*Mac file descriptor*/OSErr	error;						wprintf ("%s %s %s","@@ mopen_na file name = ", name, "\n");			wprintf ("%s %d %s","@@ mopen_na vrefnum = ", vrefnum, "\n");						fp = (MFILE *)calloc(sizeof(MFILE), 1);			if((error = fsopen(name,vrefnum,&fp->fd)) == noErr)			{	fp->vrefnum = vrefnum;				strcpy(fp->name, name);				return(fp);			}			ap_error("mopen_na",error);			free(fp);			return((MFILE *)0);}/*******************************************************************/void file_open(void){M_FILE	IdOrigFile;    /* Original file with some include inside */M_FILE	*PtIdOrigFile;M_FILE	IdComplFile;   /* Complete file with all the include integrated */char		NameComplFile[64];    wprintf ("@@@ Start file_open\n");	if( (PtIdOrigFile = mopen_local ( "TEXT" )) != 0 )	{			CopySecToFirst (&IdOrigFile,PtIdOrigFile);			wprintf ("@@@ call IntegrateTheInclude\n");		IntegrateTheInclude (&IdComplFile,&IdOrigFile,NameComplFile);		      /* Open the ComplFile and assign it to file_info */		wprintf ("%s %s %s", "NameComplFile = ", NameComplFile, "\n");		file_info = mopen_na (NameComplFile,IdOrigFile.vrefnum);		mfclose (&IdOrigFile);						if  (file_info != NULL)		{			last_file_info = *file_info;			vax_assemble( 1, &file_info );			mclose(file_info );		}		else		  wprintf ("@@@ Can't open file_info\n");							}} /* file_open */void file_save(void){MFILE *file_info;extern TEHandle TextH;	if((file_info = mcreat("File Name","Output",'EDIT','TEXT')) != 0)	{		HLock((*TextH)->hText);		mwrite(file_info->fd,*(*TextH)->hText,(*TextH)->teLength);		HUnlock((*TextH)->hText);		mclose(file_info ); 				}}long got_abort_key(void){EventRecord 			myEvent;	if( GetNextEvent(everyEvent, &myEvent)		&& (myEvent.what ==  keyDown ||  myEvent.what == autoKey)		&& (myEvent.modifiers & cmdKey))	{		if((myEvent.message & charCodeMask) == '.')			return -1;	}	return 0;}void do_assemble(void){/*	if( num_files > 0 )	{		vax_assemble( num_files, file_info );	}	else	{		aprintf( "You must first select file(s) to assemble" );	}	*/}void Link(void){}void exec_other(void){struct mac_args{	short message;	short count;	AppFile argv;} *arglist;Handle args;Handle *lmg = (Handle *)0xaec;struct Point 			dlgOrigin;			/* dialogbox top left corner*/static SFReply			theReply;			/* Data returned from dialogbox*/OSType	types[4];	dlgOrigin.h = DLGLEFT;	dlgOrigin.v = DLGTOP;	types[0] = 'APPL';	sfgetfile(&dlgOrigin,"", (FileFilterProcPtr) 0, (short)1, types, (DlgHookProcPtr)0,			&theReply);				if(theReply.good)	{	p2cstr(theReply.fName);		SetZone(SystemZone());		DisposHandle(*lmg);		args = NewHandle(sizeof(struct mac_args));		HLock(args);		SetZone(ApplicZone());		arglist = (struct mac_args *)*args;		arglist->message = 0;		arglist->count = 0;		*lmg = args;		HUnlock(args);		exec((void *)&theReply.fName,theReply.vRefNum);	}}void exec(	char *name, /*name to launch + it better be right or boom*/	short vrefnum  /*zero for current directory*/){struct launch_params appl;OSErr	error;FInfo	finfo;	if(vrefnum)		setvol((char *)0,vrefnum);	if((error = getfinfo(name,(short)0,&finfo)) == noErr)	{		if(finfo.fdType != 'APPL')			aprintf("%s is not an application",name);		else		{			c2pstr(name);			appl.name = name;			appl.altsndbuff = (short)0;			EXEC(&appl);		}	}}void exec_simul(void){struct mac_args{	short message;	short count;	AppFile argv;} *arglist;Handle args;Handle *lmg = (Handle *)0xaec;extern short appl_vrefnum;extern long	anyerrs;extern MFILE last_a_out_file;extern MFILE *a_out_file;FInfo	finfo;short vrefnum;		if(getfinfo("MacVAX",(short)0,&finfo) == noErr)		vrefnum = 0;	else		vrefnum = appl_vrefnum;	SetZone(SystemZone());	DisposHandle(*lmg);	args = NewHandle(sizeof(struct mac_args));	HLock(args);	SetZone(ApplicZone());	arglist = (struct mac_args *)*args;	arglist->message = 0;	if(a_out_file == 0 || anyerrs)		arglist->count = 0;	else	{		arglist->count = 1;		arglist->argv.vRefNum = last_a_out_file.vrefnum;		arglist->argv.fType = 'AOUT';		arglist->argv.versNum = 0;		arglist->argv.fName[0] = (unsigned char)strlen(last_a_out_file.name);		strcpy((char *)&arglist->argv.fName[1], last_a_out_file.name);	}	*lmg = args;	HUnlock(args);	exec("MacVAX",vrefnum);}void exec_edit(void){struct mac_args{	short message;	short count;	AppFile argv;} *arglist;Handle args;Handle *lmg = (Handle *)0xaec;extern short appl_vrefnum;extern long	anyerrs;extern MFILE *a_out_file;extern long num_files;FInfo	finfo;short vrefnum;extern TEHandle TextH;		if( getfinfo("edit",(short)0,&finfo) == noErr)		vrefnum = 0;	else		vrefnum = appl_vrefnum;	ZeroScrap();	HLock((*TextH)->hText);	PutScrap((*TextH)->teLength,'TEXT',*(*TextH)->hText);	HUnlock((*TextH)->hText);	UnloadScrap();	if( file_info == 0 && num_files)		exec("edit",vrefnum);	else	{		SetZone(SystemZone());		DisposHandle(*lmg);		args = NewHandle(sizeof(struct mac_args));		HLock(args);		SetZone(ApplicZone());		arglist = (struct mac_args *)*args;		arglist->message = 0;		if(file_info == 0)			arglist->count = 0;		else		{			arglist->count = 1;			arglist->argv.vRefNum = last_file_info.vrefnum;			arglist->argv.fType = 'AOUT';			arglist->argv.versNum = 0;			arglist->argv.fName[0] = (unsigned char)strlen(last_file_info.name);			strcpy((char *)&arglist->argv.fName[1], last_file_info.name);		}		*lmg = args;		HUnlock(args);		exec("edit",vrefnum);	}}