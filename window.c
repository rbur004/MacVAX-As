#include	<types.h>#include	<quickdraw.h>#include	<toolutils.h>#include	<fonts.h>#include	<events.h>#include	<windows.h>#include	<dialogs.h>#include	<menus.h>#include	<desk.h>#include	<textedit.h>#include	<scrap.h>#include	<segload.h>#include	<resources.h>#include	<OSutils.h>#include	<controls.h>#include	<memory.h>#include 	<StdLib.h>#define _WINDOW_C_#include "main.h"#include "window.h"#include "aprintf.h"#include "iow.h"#pragma segment WINDOW_Cvoid setupwindows(void){	screenRect = qd.screenBits.bounds;	SETRECT(&dragRect, 4, 20 + 4, screenRect.right-4, screenRect.bottom-4);	updateRgn = NewRgn();	/*	 * create some of our windows from the WIND resource.	 * If the WIND resource isn't there, we die.	 */	ibeamHdl = GetCursor(iBeamCursor);		/* Grab this for use later */	setup_a_window(	AswID, 0, 256, 9, update_IO_window, activate_io_window, 1, 1,					iow_click, iow_keypress, iow_undo_keypress, iow_scroll, iow_grow);	iow_init();}void setup_a_window(	short window_id,	short hscroll_id,	short vscroll_id,	short font_size,	void (*update_fn)(void),	void (*activate_window_fn)(long),	long top_margin_offset,	long growable,	void (*click_fn)(Point *),	void (*keypress_fn)(long),	void (*undo_keypress_fn)(void),	void (*doscroll_fn)(short,short),	void (*dogrow_fn)(void)){OurWindowPtr wp;FontInfo finfo;GrafPtr savePort;WindowRecord * wrecord_p;	GetPort(&savePort);	wp = window_p + (window_id - AswID);	wrecord_p = wRecord_base_p + (window_id - AswID);	wp->windowptr = GetNewWindow( window_id, (Ptr)wrecord_p, (WindowPtr) -1);	if(wp->windowptr == 0)	{		aprintf("Can't open Window, id %d",window_id);		exit(1);	}	wp->update_window = update_fn;	wp->activate_window = activate_window_fn;	wp->click_window = click_fn;	wp->keypress = keypress_fn;	wp->undo_keypress = undo_keypress_fn;	wp->doscroll = doscroll_fn;	wp->dogrow = dogrow_fn;	SetPort(wp->windowptr);	SetWRefCon(wp->windowptr, (long)window_id);	if(vscroll_id)		wp->vScroll = GetNewControl( vscroll_id, wp->windowptr); /*get a handle to a scroll bar control*/	if(hscroll_id)		wp->hScroll = GetNewControl(hscroll_id, wp->windowptr); /*get a handle to a scroll bar control*/	UsableRect(wp); 	MoveScrollBars(wp);	/*resize it to fit window*/	wp->fsize = font_size;	wp->grow = growable;	TextFont(monaco);	TextSize(wp->fsize);	TextMode(srcCopy);	TextFace(normal);		GetFontInfo(&finfo);	wp->forigin = finfo.descent + finfo.leading + 1;	wp->lsize = finfo.ascent + wp->forigin;	wp->topMargin = wp->lsize * top_margin_offset;	wp->nlines = (wp->usable.bottom - wp->topMargin) / wp->lsize ; /*calculate num lines*/	wp->secure = 0;	/*do_activate(wp,0);*/		SetPort(savePort);}void doupdate(	OurWindowPtr owp,	long erase){GrafPtr savePort;WindowPtr wp;		wp = owp->windowptr;	if( ((WindowPeek) (owp->windowptr))->visible != false )	{		GetPort(&savePort);		SetPort(wp);		BeginUpdate(wp);			if(erase)				EraseRect(&wp->portRect);			MyDrawGrow(owp);			DrawControls(wp);			if(owp->update_window)				owp->update_window();		EndUpdate(wp);		SetPort(savePort);	}}void do_activate(	OurWindowPtr wp,	long is_active){		if( ((WindowPeek) (wp->windowptr))->visible != false )	{		if (is_active) 		{			SetPort(wp->windowptr);			theActiveWindow = wp->windowptr;			TextFont((wp->windowptr)->txFont);			TextSize(wp->fsize);			TextMode(srcCopy);			if(wp->vScroll)				ShowControl(wp->vScroll);			if(wp->hScroll)				ShowControl(wp->hScroll);		} 		else 		{			if(wp->vScroll)				HideControl(wp->vScroll);			if(wp->hScroll)				HideControl(wp->hScroll);		}		MyDrawGrow(wp);	}	if(wp->activate_window)		wp->activate_window(is_active);}void MyDrawGrow(	OurWindowPtr lWindow){GrafPtr savePort;Rect GrowRect;RgnHandle	hold_h;	if(lWindow->grow)	{		GetPort(&savePort);		SetPort(lWindow->windowptr);		GrowRect = (lWindow->windowptr)->portRect;		GrowRect.left = GrowRect.right - 14;		GrowRect.top = GrowRect.bottom - 14;		hold_h = NewRgn();		GetClip(hold_h);		ClipRect(&GrowRect);		DrawGrowIcon(lWindow->windowptr);		SetClip(hold_h);		DisposeRgn(hold_h);		if(lWindow->vScroll)		{			MoveTo(GrowRect.left - 1 ,0);			Line(0, GrowRect.bottom);		}			if(lWindow->hScroll)		{			MoveTo(0 , GrowRect.top - 1);			Line(GrowRect.right,0);		}		SetPort(savePort);	}}void MoveScrollBars(	OurWindowPtr lWindow){	register Rect *rp;	rp = &((lWindow->windowptr)->portRect);	if(lWindow->vScroll)	{		HideControl(lWindow->vScroll);		MoveControl(lWindow->vScroll, rp->right-15, rp->top-1);		SizeControl(lWindow->vScroll, 16, rp->bottom-rp->top-13);		ShowControl(lWindow->vScroll);	}	if(lWindow->hScroll)	{		HideControl(lWindow->hScroll);		MoveControl(lWindow->hScroll, rp->left-1, rp->bottom-15);		SizeControl(lWindow->hScroll, rp->right-rp->left-13, 16);		ShowControl(lWindow->hScroll);	}}void UsableRect(	OurWindowPtr lWindow){register Rect pRect;		pRect = (lWindow->windowptr)->portRect;	pRect.left = pRect.left + 4;	if(lWindow->vScroll)		pRect.right = pRect.right - 16;	if(lWindow->hScroll)		pRect.bottom = pRect.bottom - 16;	lWindow->usable = pRect;}void GrowWnd(	OurWindowPtr lWindow,	Point	where){	long longResult;	short height, width;	Rect tRect;	long cw;	long lh;	if(lWindow->grow)	{		longResult = growwindow(lWindow->windowptr, &where, &dragRect);		if (longResult == 0)			return;		cw = CharWidth('0');		lh = lWindow->lsize;		height = longResult >> 16;		width = longResult & 0xFFFF;		if(lWindow->vScroll)		{			tRect = (lWindow->windowptr)->portRect;			tRect.left = tRect.right - 16;			InvalRect(&tRect);							/*blat vertical scroll bars*/		}		if(lWindow->hScroll)		{			tRect = (lWindow->windowptr)->portRect;			tRect.top = tRect.bottom - 16;				InvalRect(&tRect);									/*blat Horizontal scroll bars*/		}		tRect = (lWindow->windowptr)->portRect;		tRect.left = tRect.right - 14;		tRect.top = tRect.bottom - 14;		InvalRect(&tRect);								/*blat old grow symbol*/		SizeWindow(lWindow->windowptr, width, height, TRUE); /*get system to redraw the window*/		MoveScrollBars(lWindow);							 /*resize the scroll bars to fit*/		UsableRect(lWindow);								/*calculate new usable area*/		lWindow->nlines = (lWindow->usable.bottom - lWindow->topMargin) / lh; /*calculate num lines*/		if(lWindow->vScroll)		{			tRect = (lWindow->windowptr)->portRect;	/*mark new positions of scroll bars as needing updating*/			tRect.left = tRect.right - 16;			InvalRect(&tRect);		}		if(lWindow->hScroll)		{			tRect = (lWindow->windowptr)->portRect;			tRect.top = tRect.bottom - 16;			InvalRect(&tRect);		}		tRect = (lWindow->windowptr)->portRect;		tRect.left = tRect.right - 14;		tRect.top = tRect.bottom - 14;		InvalRect(&tRect);		if(lWindow->dogrow)			lWindow->dogrow();	}}void ScrollBits(void){Point oldOrigin;short dh, dv;long windownum;Rect	srect;long line_depth;	windownum = GetWRefCon(whichWindow) - AswID;	/*find out which window we are dealing with*/	line_depth = (window_p + windownum)->lsize;	/*depth in pixels of a line*/		oldOrigin = (window_p + windownum)->theOrigin;	/*note previous position*/	if((window_p + windownum)->hScroll)	{		(window_p + windownum)->theOrigin.h = GetCtlValue((window_p + windownum)->hScroll);	/*calculate a new position*/		dh = CharWidth('0') * (oldOrigin.h - (window_p + windownum)->theOrigin.h);	/*the thumb	 */	}	else 		dh = 0;	if((window_p + windownum)->vScroll)	{		(window_p + windownum)->theOrigin.v = GetCtlValue((window_p + windownum)->vScroll);	/*based on the position of */		dv = line_depth * (oldOrigin.v - (window_p + windownum)->theOrigin.v);	/*calc amount needed to shift to new spot*/	}	else		dv = 0;	srect =  (window_p + windownum)->usable;	if(dv)		srect.top = (window_p + windownum)->topMargin;	if((window_p + windownum)->doscroll)			(window_p + windownum)->doscroll(dh, dv);	else	{		ScrollRect(&srect, dh, dv, updateRgn);		InvalRgn(updateRgn);		doupdate((window_p + windownum),1L);	}}pascal voidScrollUp(	ControlHandle whichControl,	short theCode){	 	if (theCode == inUpButton) {		SetCtlValue(whichControl, GetCtlValue(whichControl) - 1);		ScrollBits();	}}pascal voidScrollDown(	ControlHandle whichControl,	short theCode){	 	if (theCode == inDownButton) {		SetCtlValue(whichControl, GetCtlValue(whichControl)+1);		ScrollBits();	}}void PageScroll(	short code,	short amount){	Point myPt;	do {		GetMouse(&myPt);		if (TestControl(whichControl, myPt) == code) {			SetCtlValue(whichControl, GetCtlValue(whichControl)+amount);			ScrollBits();		}	} while (StillDown());}