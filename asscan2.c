#pragma segment ASSCAN#include <CType.h>#include <String.h>#include "asscanl.h"#include "asparse.h"#include "aprintf.h"#include "iow.h"#include "asinclude.h"inttoktype	oval = NL;#define	ASINBUFSIZ	4096char	inbufunget[8];char	inbuffer[ASINBUFSIZ];char	*Ginbufptr = inbuffer;long	Ginbufcnt = 0;long	scannerhadeof;extern long curr_in_fd;/* include stack stuff(RTB) *//* can nest includes up to MAX_INCLUDES deep */ #define MAX_INCLUDES 20	INCLUDE_ENTRY include_file[MAX_INCLUDES];int include_stack_depth;/*long skip_spaces() {char ch; 	while((type+1)[ch = getchar()] == SP )		; 	return (ungetc( ch ) );}*/void fillinbuffer(void){		long	nread;		long	goal;		long	got;#ifdef DEBUG	iowprintf("fillinbuffer()\n");#endif	nread = 0;	if (scannerhadeof == 0)	{		goal = sizeof(inbuffer);		do 		{			got = mread(curr_in_fd, inbuffer + nread, goal);			if (got == 0)				scannerhadeof = 1;			if (got <= 0)				break;			nread += got;			goal -= got;		} while (goal);	}	else 	{		scannerhadeof = 0;	}	/*	 *	getchar assumes that Ginbufcnt and Ginbufptr	 *	are adjusted as if one character has been removed	 *	from the input.	 */	if (nread == 0)	{		inbuffer[0] = EOFCHAR;		nread = 1;	}	Ginbufcnt = nread - 1;	Ginbufptr = inbuffer + 1;}void scan_dot_s(	struct tokbufdesc *bufferbox){	reg	char	*inbufptr;	reg	long	inbufcnt;	reg	long	ryylval;	/* local copy of lexical value */	extern	long	yylval;		/* global copy of lexical value */	reg	long	val;		/* the value returned */		long	i;		/* simple counter */	reg	char	*rcp;			long	ch;		/* treated as a character */		long	ch1;		/* shadow value */		struct 	symtab	*op;	reg	ptrall	bufptr;		/* where to stuff tokens */		ptrall	bufub;		/* where not to stuff tokens */		long	intval;		/* value of long */		long	linescrossed;	/* when doing strings and comments */		struct	Opcode		opstruct;	reg	long	strlg;		/* the length of a string */		char mch;	int including;		/* hacky flag so that eatstr knows that it is looking for */						/* an include filename (RTB) *///	long dummy;		/* delete this at an early opportunity */	char include_name[sizeof(include_file[0].f->name)];	/* must think of some way to #define the 64 */	int leng = sizeof(include_name)-1;#ifdef DEBUG	iowprintf("scan_dot_s()\n");#endif	(bytetoktype *)bufptr = (bytetoktype *) & (bufferbox->toks[0]);		(bytetoktype *)bufub = &(bufferbox->toks[AVAILTOKS]);		MEMTOREGBUF;	if (newfflag){		newfflag = 0;		ryylval = (long)savestr(newfname, strlen(newfname)+1, STR_BOTH);		include_file[0].name_ptr = (struct strdesc *)ryylval;	/* the name of the original file (RTB) */		ptoken(bufptr, IFILE);				ptoken(bufptr, STRING);		pptr(bufptr, ryylval);		ptoken(bufptr, ILINENO);		ptoken(bufptr, INT);		pint(bufptr,  1);	}	while (bufptr < bufub){   loop:   		ryylval = (type+1)[ch = getchar()];		including = 0;	/* the default. We are not looking for an include string */			switch(ryylval) {				case SCANEOF:	endoffile: 		if (include_stack_depth>0)	/* are we in an included file ? (RTB) */			{				/* close it if it is open */				if (include_file[include_stack_depth].f !=0)					mclose(include_file[include_stack_depth].f);				/* reduce the level of include nesting */				include_stack_depth--;				scannerhadeof = 0;	/* we aren't finished yet! */				/* carry on with old file */				curr_in_fd = include_file[include_stack_depth].f->fd;				Ginbufcnt = 0;				MEMTOREGBUF;				/* insert .file and .lineno */				scanlineno = include_file[include_stack_depth].lineno;				ptoken(bufptr, IFILE);						ptoken(bufptr, STRING);				pptr(bufptr,  (long)include_file[include_stack_depth].name_ptr);				ptoken(bufptr, ILINENO);				ptoken(bufptr, INT);				pint(bufptr,  scanlineno);								/* iowprintf("resuming at %d\n",scanlineno); */				goto builtval;			}		else{				inbufptr = 0;			ptoken(bufptr, PARSEEOF);			goto done;			}	case DIV:		/*process C style comments*/		if ( (ch = getchar()) == '*') {  /*comment prelude*/			long	incomment;			linescrossed = 0;			incomment = 1;			ch = getchar();	/*skip over the * */			while(incomment)			{				switch(ch){				case '*':					ch = getchar();					incomment = (ch != '/');					break;				case '\n':					scanlineno++;					linescrossed++;					ch = getchar();					break;				case EOFCHAR:					goto endoffile;				default:					ch = getchar();					break;				}			}			val = ILINESKIP;			ryylval = linescrossed;			goto ret;		} else {	/*just an ordinary DIV*/			ungetc(ch);			val = ryylval = DIV;			goto ret;		}	case SH:	case LITOP_VMS:		if (oval == NL)		{			/*			 *	Attempt to recognize a C preprocessor			 *	style comment '^#[ \t]*[0-9]*[ \t]*".*"			 */			ch = getchar();	/*bump the #*/			while (INCHARSET(ch, SPACE))			{					ch = getchar();/*bump white */			}				if (INCHARSET(ch, DIGIT))			{				intval = 0;				while(INCHARSET(ch, DIGIT))				{						intval = intval*10 + ch - '0';					ch = getchar();				}				while (INCHARSET(ch, SPACE))				{						ch = getchar();				}				if (ch == '"')				{					ptoken(bufptr, ILINENO);					ptoken(bufptr, INT);					pint(bufptr, intval - 1);					ptoken(bufptr, IFILE);											/*					 *	The '"' has already been					 *	munched					 *						 *	eatstr will not eat					 *	the trailing \n, so					 *	it is given to the parser					 *	and counted.					 */					goto eatstr;				}			}			/*			 *	Well, its just an ordinary decadent comment			 */			while ((ch != '\n') && (ch != EOFCHAR)) 			{				ch = getchar();							}			if (ch == EOFCHAR)				goto endoffile;			val = ryylval = oval = NL;			scanlineno++;		}		else if(ryylval == SH)		{			/*			 *	Well, its just an ordinary decadent comment			 */			while ((ch != '\n') && (ch != EOFCHAR)) 			{				ch = getchar();							}			if (ch == EOFCHAR)				goto endoffile;			val = ryylval = oval = NL;			scanlineno++;		}		else			val = ryylval;		goto ret;	case NL:		scanlineno++;		val = ryylval;		goto ret;	case SP:		oval = SP;	/*invalidate ^# meta comments*/		goto loop;	case REGOP:		/* % , could be used as modulo, or register*/		ch = getchar();		if (INCHARSET(ch, DIGIT)){			ryylval = ch-'0';			if (ch=='1') {				if (INCHARSET( (ch = getchar()), REGDIGIT))					ryylval = 10+ch-'0';				else					ungetc(ch);			}			/*			 *	God only knows what the original author			 *	wanted this undocumented feature to			 *	do.			 *		%5++ is really  r7			 */			while(INCHARSET( (ch = getchar()), SIGN)) 			{				if (ch=='+')					ryylval++;				else					ryylval--;			}			ungetc(ch);			val = REG;		} else {			ungetc(ch);			val = REGOP;		}		goto ret;	case ALPH:		ch1 = ch;		if (INCHARSET(ch, SZSPECBEGIN)){			if( (ch = getchar()) == '`' || ch == '^'){				ch1 |= 040;	/*convert to lower*/				switch(ch1){				case 'b':	ryylval = 1;	break;				case 'w':	ryylval = 2;	break;				case 'l':	ryylval = 4;	break;				default:	ryylval = d124;	break;				}				val = SIZESPEC;				goto ret;			} else {				ungetc(ch);				ch = ch1;	/*restore first character*/			}		}		rcp = yytext;		do {			if (rcp < &yytext[NCPName])				*rcp++ = ch;		} while (INCHARSET ( (ch = getchar()), ALPHA | DIGIT));		*rcp = '\0';		while (INCHARSET(ch, SPACE))		{				ch = getchar();		}		ungetc(ch);			switch((op = *lookup(1))->s_tag){		case 0:		case LABELID:			/*			 *	Its a name... (Labels are subsets of name)			 */			ryylval = (long)op;			val = NAME;			break;		case INST0:		case INSTn:		case IJXXX:			opstruct.Op_popcode = ( (struct instab *)op)->i_popcode;			opstruct.Op_eopcode = ( (struct instab *)op)->i_eopcode;			val = op->s_tag;			break;		case IINCLUDE:		#ifdef DEBUG			iowprintf("Found an include at line %d!\n",scanlineno);			iowprintf("%d from the end of the buffer\n",bufub-bufptr);		#endif			if (include_stack_depth == MAX_INCLUDES) {				linescrossed = lineno;				lineno = scanlineno;				yyerror(".includes nested more than %d times",MAX_INCLUDES);				lineno = linescrossed;				val = BADCHAR;				goto ret;			}			include_file[include_stack_depth].lineno = scanlineno;	/* store current lineno */													/* so that we can return there later */			include_stack_depth++;			ch = getchar();	/*kill the spaces*/			while (INCHARSET(ch, SPACE))			{					ch = getchar();			}			/* include needs a file name */			if (ch == '"'){				/* new file starts from line number one */				ptoken(bufptr, ILINENO);				ptoken(bufptr, INT);				pint(bufptr, 1);				/* put a .file "STRING" into the buffer */				ptoken(bufptr, IFILE);				including = 1;						/*				 *	The '"' has already been				 *	munched				 *					 *	eatstr will not eat				 *	the trailing \n, so				 *	it is given to the parser				 *	and counted.				 */				goto eatstr;			}			/* moan about not having an include name */			linescrossed = lineno;			lineno = scanlineno;			yyerror("Include must have a file name");			lineno = linescrossed;			val = BADCHAR;			goto ret;		default:			ryylval = ( (struct instab *)op)->i_popcode;			val = op->s_tag;			break;		}		goto ret;	case DIG:		/*		 *	restore local inbufptr and inbufcnt		 */		REGTOMEMBUF;		val = number(ch);		MEMTOREGBUF;		/*		 *	yylval or yybignum has been stuffed as a side		 *	effect to number(); get the global yylval		 *	into our fast local copy in case it was an INT.		 */		ryylval = yylval;		goto ret;	case LSH:	case RSH:		/*		 *	We allow the C style operators		 *	<< and >>, as well as < and >		 */		if ( (ch1 = getchar()) != ch)			ungetc(ch1);		val = ryylval;		goto ret;	case MINUS:		if ( (ch = getchar()) =='(')			ryylval=val=MP;		else {			ungetc(ch);			val=MINUS;		}		goto ret;	case SQ:		if ((ryylval = getchar()) == '\n')			scanlineno++;		/*not entirely correct*/		val = INT;		goto ret;	case DQ:	   eatstr:	    rcp = include_name;	/* where to copy include filename */		linescrossed = 0;		for (strlg = 0; /*VOID*/; strlg++)		{						ch = getchar();											switch(ch)			{		    case '"':				goto tailDQ;		    default:		    stuff:				mputc(ch, strfile);				if (including)	/* keep a copy if we are including (RTB) */					if (strlg<leng )						*rcp++ = ch;					else {						linescrossed = lineno;						lineno = scanlineno;						yyerror(".include pathname too long");						lineno = linescrossed;						val = BADCHAR;						goto ret;					}				break;		    case '\n':			{			long hold_lineno = lineno; /*need to fudge this so yywarning can give the correct line number*/				lineno = scanlineno;								/* Shut up this message because warning given inside the first pass */				/* see asinclude.c */				/* yyerror("New line in a string constant."); */								lineno = hold_lineno;				ungetc('\n'); /*new line not part of string*/				goto tailDQ;  /*Assume End of String and exit*/				break; 			}							case EOFCHAR: /*Check for EOF. They seem to have forgotten this could happen*/				mputc('\n', strfile);				ungetc(EOFCHAR);				goto tailDQ;				aprintf("Not possible to reach this statement: 3");				break;	/*never reach this break*/		    case '\\':				ch = getchar();		/*skip the '\\'*/				if ( INCHARSET(ch, BSESCAPE))				{					switch (ch)					{				  	case 'b':  ch = '\b'; goto stuff;				 	 case 'f':  ch = '\f'; goto stuff;				  	case 'n':  ch = '\n'; goto stuff;				 	 case 'r':  ch = '\r'; goto stuff;				 	 case 't':  ch = '\t'; goto stuff;					}				}				if ( !(INCHARSET(ch, OCTDIGIT)) ) 					goto stuff;				i = 0;				intval = 0;				while ( (i < 3) && (INCHARSET(ch, OCTDIGIT)))				{					i++;					intval <<= 3;					intval += ch - '0';					ch = getchar();				}				ungetc(ch);				ch = (char)intval;				goto stuff;		    }		}  /* end for */					tailDQ: ;		/*		 *	account for any lines that were crossed		 */		if (linescrossed){			ptoken(bufptr, ILINESKIP);			pint(bufptr, linescrossed);		}		/*		 *	Cheat: append a trailing null to the string		 *	and then adjust the string length to ignore		 *	the trailing null.  If any STRING client requires		 *	the trailing null, the client can just change STRLEN		 */		mputc(0, strfile);		ryylval = (long)savestr((char *)0, strlg + 1, STR_FILE);		val = STRING;		((struct strdesc *)ryylval)->sd_strlen -= 1;		/* crummy use of a flag to save me having to do extra work (RTB) */		/* if this flag is set then we have been looking for an include filename */		if (including) {			*rcp = 0;	/* terminate string */			/* iowprintf("Including %s %d\n",include_name,leng); */			/* first see if the include file exists and can be opened */			if ((include_file[include_stack_depth].f =				mopen_na(include_name,include_file[0].f->vrefnum)) == 0) {					yyerror("Either could not find or open include file: %s", include_name);										/* finish off the IFILE that was started with IINCLUDE */					ptoken(bufptr, STRING);					pptr(bufptr,  (long)ryylval);										/* restore old file */					include_stack_depth--;					scanlineno = include_file[include_stack_depth].lineno;					ptoken(bufptr, ILINENO);					ptoken(bufptr, INT);					pint(bufptr, scanlineno);					/* put a .file "STRING" into the buffer */					ptoken(bufptr, IFILE);					ryylval = (long)include_file[include_stack_depth].name_ptr;					goto ret;	/* leave quietly */			}			/* we have to rewind the input file so that next time we visit */			/* this file we will be starting at the right place. */			/* Rewind by the amount left in the inbuffer */#ifdef DEBUG			GetFPos(curr_in_fd, &dummy);			iowprintf("discarding %d bytes from pos %d\n",inbufcnt,dummy);#endif			mlseek(curr_in_fd,-inbufcnt,1);			/* we want to change the input file */			/* All vrefnums are the same so can use include_file[0].f->vrefnum */			curr_in_fd = include_file[include_stack_depth].f->fd;			/* store a pointer into the strfile to the name of the include file */			include_file[include_stack_depth].name_ptr = (struct strdesc *) ryylval;			scannerhadeof = 0;			/* refil the input buffer */			Ginbufcnt = 0;			MEMTOREGBUF;#ifdef dead			fillinbuffer();			MEMTOREGBUF;		/* this action skips the first character in the inbuffer */			/* so must undo */			ch = inbufptr[-1];			ungetc(ch);#endif/* set the line number to one */			scanlineno = 1;#ifdef DEBUG			/* temporary debugging info. (RTB) */			iowprintf("Dumping include stack\n");			for(dummy=0;dummy<=include_stack_depth;dummy++)				iowprintf("%d. %s\n",dummy,include_file[dummy].f->name);#endif			/* and get clear! */			goto ret;		}		goto ret;	case XOR:		/* MAC port: add register masks */		/* convert to lower, is it a mask? */		if( tolower( mch = getchar()) != 'm' )  		{			/* NO!  just an ordinary XOR */			ungetc( mch );			val = ryylval;			goto ret;		}		/* it is the start of a mask, */		val = MASK;		goto ret;					case BADCHAR:	   badone:		linescrossed = lineno;		lineno = scanlineno;		yyerror("Illegal character mapped: %d, char read:(octal) %o",			ryylval, ch);		lineno = linescrossed;		val = BADCHAR;		goto ret;	default:		val = ryylval;		goto ret;	}	/*end of the switch*/	/*	 *	here with one token, so stuff it	 */   ret:	  	oval = val;	ptoken(bufptr, val);	switch(val){		case	ILINESKIP:				pint(bufptr, ryylval);				break;		case	SIZESPEC:				pchar(bufptr, ryylval);				break;		case	BFINT:	plong(bufptr, ryylval);				break;		case	INT:	plong(bufptr, ryylval);				break;		case 	BIGNUM:	pnumber(bufptr, yybignum);				break;		case	STRING:	pptr(bufptr, (long)(char *)ryylval);				break;		case	NAME:	pptr(bufptr, (long)(struct symtab *)ryylval);				break;		case	REG:	pchar(bufptr, ryylval);				break;			case	INST0:		case	INSTn:				popcode(bufptr, opstruct);				break;		case 	IJXXX:				popcode(bufptr, opstruct);				pptr(bufptr, (long)(struct symtab *)symalloc());				break;		case	ISTAB:		case	ISTABSTR:		case	ISTABNONE:		case	ISTABDOT:		case	IALIGN:				pptr(bufptr, (long)(struct symtab *)symalloc());				break;	/*	 *	default:	 */	 }	 builtval: ;  }			/*end of the while to stuff the buffer*/   done:	bufferbox->tok_count = (bytetoktype *)bufptr - &(bufferbox->toks[0]);	/*	 *	This is a real kludge:	 *	 *	We put the last token in the buffer to be  a MINUS	 *	symbol.  This last token will never be picked up	 *	in the normal way, but can be looked at during	 *	a peekahead look that the short circuit expression	 *	evaluator uses to see if an expression is complicated.	 *	 *	Consider the following situation:	 *	 *	.word	45		+	47	 *        buffer 1      |  buffer 0	 *	the peekahead would want to look across the buffer,	 *	but will look in the buffer end zone, see the minus, and	 *	fail.	 */	ptoken(bufptr, MINUS);	REGTOMEMBUF;#ifdef DEBUG	iowprintf("reached the end of a buffer \n");#endif#ifdef roberts_debugging_code		{ long dummy = mftell(strfile);		  iowprintf("flying fish pos %d %d\n",dummy,strfilepos); /* (RTB) */		}#endif}