/*******************************************************************  File Name : asinclude.c*  Goal : Integrate all the include instruction available inside *		OrgFile to build th CmplFile => Algo :*			- Sequential reading of the original files and building*				of a temporary file (CmplFile (Complete file)) being*				the addition of all the little files.*				Its hold also some internal identification to autorise*				the compiler to give some information related to the*				original files in case of bugs =>*					- .file  original_file_name.*					- .line	Where_to_start_to_count_the_line_number.**  Rem : A comment will be tolerate on the same line that an include*		instruction, but nothing else.**  Improvment2 : error message feed back given from the appended file *		with the (.line, .file) directives =>*		1) Need to keep the same number of line than the original file.*		2) Need to write in the head of each included part, the file name and*			the line number (also for the main file).*/#include <ctype.h>#include <String.h>#include <Strings.h>#include <StdLib.h>#include <Stdio.h>#include	<errno.h>#include "mstdio.h"#include "iow.h"#include  "asinclude.h"#define EndOfStr  '\0'#define LongNormStr  255#define LimStackIncl  20    /* Form 0 to 20 */#define StrDirectIncl ".include"     /* String used inside the assembler program */#define TheIncludeBuffer  "TempX7178X"  	/* Name of the file holding 		*/														/* all the other included files. */ /* Stack of the source file identifier, to follow the complete   *//* program script, given by the main file and all the associate  *//* includes. The main file is accessible with the index == 0 	  */ typedef  struct  {  		int  IndexCF;							/* Index current file, is alway */													/* on the file currently read.  */															M_FILE  	*FileId[LimStackIncl];    /* File identifier POINTER otherwise crash! */				int		CurLineNb[LimStackIncl];	/* Current line number of the file */			} TStackFId;/********************/	/* GLOBAL VARIABLES *//********************//******************************************* To catch the file name associate with * the .file compiler instrc. */char	VectInclFileName [IndxMaxIFN-1][SizeFileNameVI];   /* Vector */int		IndxVectFN;	   		/* Index of the vector */int		LastIndxVectFN;		/* Last index of the vector */char		MainFileName[SizeFileNameVI];  /* To give it to asmain.c (to display it) *//*******************************************//*******************************************************************/void  PrintIdFile(  M_FILE	*First){  iowprintf ("################\n");  iowprintf ("%d %s", First->_cnt, "\n");  iowprintf ("%c %s", First->_ptr, "\n");  iowprintf ("%c %s", First->_base, "\n");  iowprintf ("%d %s", First->_bufsiz, "\n");  iowprintf ("%d %s", First->_flag, "\n");  iowprintf ("%d %s", First->_file, "\n");  iowprintf ("%d %s", First->vrefnum, "\n");  iowprintf ("%s %s", First->name, "\n");  iowprintf ("################\n");  } /* PrintIdFile *//*******************************************************************  Replace all the include instructions with the content of the*  pointed file. *  Return true if everythings are ok, or false if there is a*  problem.**  IdCmplFile : Identificator for the complete file before and after*					absorbtion of the includes.*  IdOrgFile : Identificator for the original file, with include *					instructions.   *  NameCmplFile : Name of the complete file, given back because we*					need it to open it again after creation (mopen_na),*					and we need this string because the closure of this*					file make the  IdCmplFile->name not available.**/Boolean  IntegrateTheInclude(  M_FILE  *IdCmplFile,       M_FILE  *IdOrgFile,      char    *NameCmplFile){   /* VAR *///	char  CurrentStr[LongNormStr];		TStackFId  StackFId;  /* Stack of file identifier */	char  CurStringCF[LongNormStr];  /* Current string of the current file */	char  CurStringOC[LongNormStr]; 	/* Current string of the current file */												/* Outside any Comments or Quotation  */													Boolean  InsideComOn;  	/* On if the end of the precedent string */									/* was inside a comment. */																			Boolean  InsideQuoOn;  	/* On if the end of the precedent string */									/* was inside a quotation mark. */										Boolean	TouchQuo;		/* True if we met one or many " on a line */											Boolean  ContinueFileSwitch;  																			M_FILE *PtIdCurFile;  	/* Identifier of the current file */	M_FILE *PtIdNewFile;  	/* Identifier of the new file (basicly just a buffer */									/* to do a couple of test. */		char  *ResultGetCurS;  	/* Result get current string (Null or not) */	char  NewFileName[64];  /* New current file name associate with an include */	Boolean  OutBecNewIncl; /* Go out because a new include has been found */		int	indexLN;  			/* Index to init the line number of the stack */	/*****************************/   /* BEGIN IntegrateTheInclude */		strcpy (MainFileName,IdOrgFile->name);		/* To display it later in asmain.c */		IndxVectFN = 0; /* !!global indice */	LastIndxVectFN = 0;	   IdCmplFile = mfopen(TheIncludeBuffer,IdOrgFile->vrefnum,"w");   if  (IdCmplFile == NULL)	{		iowprintf ("can't open IdCmplFile\n");		iowprintf ("%s %s","Orig file name = ",IdOrgFile->name);		iowprintf ("%s %d", "Orig file vrefnum = ", IdOrgFile->vrefnum);		return (False);	}	else	{	   /***********************************		*  Situation :		* 	- OrgFile open to be read.		*	- CmplFile open to be written.		*/				/* Init the stack of file identifiers */		StackFId.IndexCF = 0;		StackFId.FileId[0] = IdOrgFile;		PtIdCurFile = IdOrgFile;				for (indexLN = 0; indexLN <= LimStackIncl;  ++indexLN)			StackFId.CurLineNb [indexLN] = 0;  /* Init the current line number of the files */				/* Write the file and line label for the main file */		WriteFNLL (IdCmplFile, IdOrgFile->name,0);		 						/*****************************************************/		/* Loop used to switch from one file to an other one */		ContinueFileSwitch = True;		ResultGetCurS =  mfgets (CurStringCF,LongNormStr,PtIdCurFile);      while (ContinueFileSwitch)		{ /* File switch */				/**************************************************************/		/* Read the current stringCF accross the current file 		  */		/* until its end or an include. 										  */		/* Care about comment (like in C)  and string (like in C) ""  */		InsideComOn = False;		InsideQuoOn = False;		OutBecNewIncl = False;		   	while (  (ResultGetCurS != NULL)  &&  !OutBecNewIncl )   	{			TouchQuo = False;			if  (PartOutsideCom(CurStringOC,&InsideComOn,&InsideQuoOn,&TouchQuo,CurStringCF))			{						   	/* CurStringOC has been purged of any comment */								if  ( (!InsideQuoOn) && FoundIncludeLine (NewFileName,CurStringOC,&InsideQuoOn) )				{						   /* OPEN the new file, load the IdStack and */					/* actualize the current variables.			 */					PtIdNewFile = mfopen (NewFileName,PtIdCurFile->vrefnum,"r");					if  (PtIdNewFile != NULL)					{					   StackFId.FileId [StackFId.IndexCF] = PtIdCurFile; 	/* To come back */						PtIdCurFile = PtIdNewFile;				/* Actualize the current file */						OutBecNewIncl = True;										   }					else					{						iowprintf ("%s %d %s", "Mac error no : ", errno, "\n");					  	iowprintf ("%s %s %s","Can't open ",NewFileName,"\n");						iowprintf ("Check .include directive, File : %s \n", PtIdCurFile->name);						iowprintf ("Line : %d \n", StackFId.CurLineNb [StackFId.IndexCF]+1);					}				}				else 				{				  /* Put the current string inside the complete file    */				  /* => the complete file would appear with no comment. */				  mfputs (CurStringOC,IdCmplFile);				  				  if  (InsideQuoOn)				  {				  		iowprintf ("Error : String on many lines : ");						iowprintf ("In %s line %d\n",PtIdCurFile->name,StackFId.CurLineNb [StackFId.IndexCF]+1);				  }				}			}			else			{				/* else : write a new line in the place of the comment */				mfputs ("\n",IdCmplFile);			}						ResultGetCurS =  mfgets (CurStringCF,LongNormStr,PtIdCurFile);		  	++StackFId.CurLineNb [StackFId.IndexCF];   /* line of the current file */   	}; /* Loop on current file */				/* Adapt for (and do) current file switching */		if  (OutBecNewIncl)		{			if  (StackFId.IndexCF < LimStackIncl)			{				++StackFId.IndexCF;									StackFId.FileId [StackFId.IndexCF] = PtIdCurFile; 								/* Need to write a file label before to start this new include */				/* Need also to init the line counter of this new include */				StackFId.CurLineNb [StackFId.IndexCF] = 0;				WriteFNLL (IdCmplFile,PtIdCurFile->name,StackFId.CurLineNb [StackFId.IndexCF]);			}			else			  iowprintf ("Too many include\n");			}		else  /* Out because end of file */		{  			/* Close the present file and come back to the actual */			if  (StackFId.IndexCF > 0)			{				/* Init the current line counter of the present file */				StackFId.CurLineNb [StackFId.IndexCF] = 0;							/* Close the current file */				if (mfclose (StackFId.FileId [StackFId.IndexCF]) != NULL) 					{						iowprintf ("Can't close %s \n", StackFId.FileId [StackFId.IndexCF]->name);					}									--StackFId.IndexCF;				PtIdCurFile = StackFId.FileId [StackFId.IndexCF];				/* Because come back, need to write again a file line label */				/* indicating the continuation of the precedent file.			*/				WriteFNLL (IdCmplFile,PtIdCurFile->name,StackFId.CurLineNb [StackFId.IndexCF]);								ResultGetCurS =  mfgets (CurStringCF,LongNormStr,PtIdCurFile);							}			else  /* else : end of the problem */			  ContinueFileSwitch = False;		}				}  /* File switch */			/* give back the name of the complete file and close it */			strcpy (NameCmplFile,IdCmplFile->name);		if (mfclose (IdCmplFile) != 0) 			iowprintf ("Can't close IdCmplFile  asinclude.c(IntegrateTheInclude)\n");				--LastIndxVectFN;  	/* To match the last element  */		return (True);	}}  /* IntegrateTheInclude *//*******************************************************************	Write the File Name and Line Label inside the given file.*  FLL : File and Line Label.*  !! Load the global vector of .file name.*	*	M_FILE	*IdGivFile,    (given file to write in)*	char		*FNameLabel,	(given file name)*	int		FLineLabel		(given line label)*/void	WriteFNLL(	M_FILE	*IdGivFile,	char		*FNameLabel,	int		FLineLabel	){	/* VAR */	char  StrTmp [256];		/* BEGIN */	sprintf 	(StrTmp, "%s %s %c %s %c %s", "\n", CmplDir_file , '"',FNameLabel,'"', "\n");	mfputs	(StrTmp,IdGivFile);		sprintf 	(StrTmp, "%s %d %s", CmplDir_line , FLineLabel, "\n");	mfputs	(StrTmp,IdGivFile);			/* Load the global vector of name associate with .file */	strcpy (VectInclFileName[IndxVectFN], FNameLabel);	if  (IndxVectFN < IndxMaxIFN)	{		++IndxVectFN;		++LastIndxVectFN;	}	else	{		iowprintf ("Too many  '.file'  in the appended file\n");		iowprintf ("therefore : the errors messages will have\n");		iowprintf ("an incorrect file name identification\n");	}		} /* WriteFNLL *//*******************************************************************  Effect : **  - If the string is a complete comment (no instruction on*    the line)  by itself, the function will be False and no *    string will be returned.*  - If the string has a part of comment and a part of*    instruction, the function will be true and a string*    holding the instruction part will be returned.*  *	CurPS : Current purged string from any comment, returned.**  InsideComOn : True if we are inside a comment, in relation*			with the position of the character index of the string, for*			the outside, keep the value it had on the last character.**  InsideQuoOn : Idem than for comment but don't influence the result*  		of the function except for itself, in use for outside to detect*			an improbable include inside some quotation marks.** 	TouchQuo : True if we touched the InsideQuoOn on the line.**  CurOS : Current original string.**/Boolean  PartOutsideCom(	char  	*CurPS,	Boolean 	*InsideComOn,	Boolean 	*InsideQuoOn,	Boolean  *TouchQuo,	char    	*CurOS){	/* VAR */	int	IndxOS;		/* Index char of the original string */		int   IndxPS;		/* Index char of the purged string, on the */							/* position where to add a character.		 */								char  OldChar;		/* Old character */	char  CurChar;		/* Current character */   		/* BEGIN */	*TouchQuo = False;			OldChar = EndOfStr;	CurChar = EndOfStr;	if  (CurOS[0] != EndOfStr)	{		OldChar = CurOS[0];		CurChar = CurOS[1];   }	IndxOS = 1;	IndxPS = 0;	while  (OldChar != EndOfStr)	{				if  (*InsideComOn)  		{			/* Look for a end of comment */			if  (  (OldChar == '*')  &&  (CurChar == '/')  )			{				*InsideComOn = False;								/* Jump the / */				OldChar = CurChar;				++IndxOS;				CurChar = CurOS[IndxOS];							}		   /* And don't write anything inside CurPS */		}		else		{			/* We have only to care about the " outside comment */			if  (OldChar == '"')			{				*InsideQuoOn = !(*InsideQuoOn);				*TouchQuo = True;			}									if  (*InsideQuoOn)			{									CurPS[IndxPS] = OldChar;				++IndxPS;			}			else			{				if  (  (OldChar == '/')  &&  (CurChar == '*')  )					*InsideComOn = True;				else				{					/* We are outside any comment => can COPY the string */					CurPS[IndxPS] = OldChar;					++IndxPS;				}			}		}				OldChar = CurChar;		++IndxOS;		CurChar = CurOS[IndxOS];	}				if  (IndxPS != 0)	{		/* We return a string outside any comments */				/* Add the (\n) because it has been absorbed by the comment */		if  (*InsideComOn)		{			CurPS[IndxPS] = '\n';			++IndxPS;		}				CurPS[IndxPS] =  EndOfStr;		return (True);	}	else	{		CurPS[IndxPS] = EndOfStr;  /* make it cleaner */		return (False);	}	}  /* PartOutsideCom *//******************************************************************* True if a real include directive has been found inside. *   NewFName   : File name given with the include instruction *   CurPS   	: Current purged string free of any comment*	 QuotaOn		: In or out any quotation, to be able to eliminate*					  an include inside some ""*/Boolean  FoundIncludeLine(  char  *NewFName,  char  *CurPS,  Boolean *QuotaOn){	/* VAR */	int  StartSubS;  	/* Start of the substring */ 	int  IndxPS;	 	/* Index purged string */	int  IndxFN;		/* Index file name */	char CpyStrIncl[64];  			/* BEGIN */	strcpy (CpyStrIncl,StrDirectIncl);	if  (GiveStartSubS (&StartSubS,CurPS,CpyStrIncl))	{		/* Look for the filename indicated */		IndxPS = StartSubS + strlen(StrDirectIncl);				/* Jump the white */		while  ( (CurPS[IndxPS] == ' ')  ||  (CurPS[IndxPS] == '\t') )			++IndxPS;					if  (CurPS[IndxPS] == '"')		/* Jump the quotation mark, should work also with */			++IndxPS;						/* no quotation mark, except if the file name is */												/* terminated with some inexpected whites.	*/				/* Memorise the file name until "Quotation mark or new line" */		/* Accept some file name with some white inside. */		IndxFN = 0;		while  ( (CurPS[IndxPS] != '"') && (CurPS[IndxPS] != '\n') &&\					(CurPS[IndxPS] != '\r') && (CurPS[IndxPS] != '\t') )		{			NewFName [IndxFN] = CurPS[IndxPS];			++IndxFN;			++IndxPS;		};				NewFName [IndxFN] = EndOfStr;	   return (True);	}	else		return (False);}  /* FoundIncludeLine *//******************************************************************* True if the string2 is include inside the string1 and* give back the starting position of the substring.* Not working if s2 is NULL.*/Boolean  GiveStartSubS(	int   *StartSS,	char	*String1,	char 	*String2){	/* VAR */	int	LimStartSS;	int   IndxS1;	int   IndxS2;	Boolean  FoundSS;   /* Found sub string */				/* BEGIN */		LimStartSS = strlen (String1) - strlen(String2);	*StartSS = 0;	FoundSS = False;	while ( (*StartSS < LimStartSS)  &&  !(FoundSS) )	{		while ( (*StartSS < LimStartSS) && (String1[*StartSS] != String2[0]) )			++(*StartSS);					if  (String1[*StartSS] == String2[0])		{			IndxS1 = *StartSS;			IndxS2 = 0;			do			{				++IndxS1;				++IndxS2;			} while ((String1[IndxS1] == String2[IndxS2]) && 						(String2[IndxS2] != EndOfStr ));									if  (String2[IndxS2] == EndOfStr)				FoundSS = True;			else			  ++(*StartSS);		}	}		return (FoundSS);	} /* GiveStartSubS */