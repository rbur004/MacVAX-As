#include 	"mstdio.h"#include	<OSutils.h>#include	<StdLib.h>#include "as.h"#include "unix.h"#include "asmain.h"#include "iow.h"#define MAXMEM	131072		/* max we'll need *//* *	These are simulations of the  *	the unix utilities or system *	programs which do not exist on  *	the mac. */ #define MIN( x, y )		((x) < (y)? (x) : (y))char *memlow;			/* base of assembler memory */long mem_size = 0;		/* memory allocated */long mem_allocated = 0;	/* amount currently allocated */#pragma segment UNIXchar *sbrk(	long num){		char *loc;		if( num == 0)			return( memlow + mem_allocated );	/* shows next free location */				if( num < 0 || (mem_allocated + num >= mem_size))		{			aprintf( "couldn't sbrk.\n");			return( (char *)(-1) ); 		/* error */		}		loc = memlow + mem_allocated;		mem_allocated = ((mem_allocated + num) + 3 ) & ~0x3 ; /*next address always multiple of 4*/				return( loc );}	/* *	try to handle memory just like the real VAX *	sbrk would be done. */void init_sbrk(void){	mem_size = MAXMEM;	memlow = calloc(mem_size,1L);	if( memlow == (char *)0 )	{		aprintf( "Unable to allocate enough memory!\n" );		exit(-1);	}	mem_allocated = 0;}		/* *	cvtfd( src, dest ) * *	exact copy from floating point *	to double floating point. *	(4 bytes to 8 bytes) */void cvtfd(	long *src,	long *dest){	dest[0] = *src;	dest[1] = 0;}/* *	cvtdf( src, dest ) * *	rounded copy from double floating *	point to floating point. *	(8 bytes to 4 bytes).   *	PRECISION IS LOST! */void cvtdf(	long *src,	long *dest){	*dest = *src;}/*  *	Need (for debugging purposes) *	a unix-like sleep facility. */ void sleep(	long secs){	long ticks = secs * 60;	long finalticks; /* dont really want */	SysBeep(5);	Delay( ticks, &finalticks );}/* *	swaps words for mac (always swaps words )  */char *reverse(	register unsigned char *q){	static unsigned long x[4];register unsigned char *p;long k;	q += 16;	for(k = 3; k >= 0; k--)	{		p = (unsigned char *)&x[k];		*p++ = *--q;*p++ = *--q;*p++ = *--q;*p = *--q;	}	return((char *)x);}#ifdef 0void reverse2(	register unsigned char *q,	long dst[4]){	long k;register unsigned char *p;		q += 16;	for(k = 3; k >= 0; k--)	{		p = (unsigned char *)&dst[k];		*p++ = *--q;*p++ = *--q;*p++ = *--q;*p = *--q;	}}#endif